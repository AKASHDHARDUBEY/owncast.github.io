{"version":3,"file":"static/chunks/7466-324a99f699cfa686.js","mappings":"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","sources":["webpack://_N_E/./interfaces/client-config.model.ts","webpack://_N_E/./services/client-config-service.ts","webpack://_N_E/./services/chat-service.ts","webpack://_N_E/./services/websocket-service.ts","webpack://_N_E/./interfaces/server-status.model.ts","webpack://_N_E/./components/stores/application-state.ts","webpack://_N_E/./components/stores/eventhandlers/connected-client-info-handler.ts","webpack://_N_E/./services/status-service.ts","webpack://_N_E/./components/stores/eventhandlers/handleNameChangeEvent.tsx","webpack://_N_E/./components/stores/ClientConfigStore.tsx","webpack://_N_E/./interfaces/socket-events.ts","webpack://_N_E/./utils/helpers.js","webpack://_N_E/./utils/localStorage.ts","webpack://_N_E/<anon>"],"sourcesContent":["export interface ClientConfig {\n  name: string;\n  title?: string;\n  summary: string;\n  offlineMessage?: string;\n  logo: string;\n  tags: string[];\n  version: string;\n  nsfw: boolean;\n  extraPageContent: string;\n  socialHandles: SocialHandle[];\n  chatDisabled: boolean;\n  externalActions: any[];\n  customStyles: string;\n  appearanceVariables: Map<string, string>;\n  maxSocketPayloadSize: number;\n  federation: Federation;\n  notifications: Notifications;\n  authentication: Authentication;\n  socketHostOverride?: string;\n}\n\ninterface Authentication {\n  indieAuthEnabled: boolean;\n}\n\ninterface Federation {\n  enabled: boolean;\n  account: string;\n  followerCount: number;\n}\n\ninterface Notifications {\n  browser: Browser;\n}\n\ninterface Browser {\n  enabled: boolean;\n  publicKey: string;\n}\n\ninterface SocialHandle {\n  platform: string;\n  url: string;\n  icon: string;\n}\n\nexport function makeEmptyClientConfig(): ClientConfig {\n  return {\n    name: '',\n    summary: '',\n    offlineMessage: '',\n    logo: '',\n    tags: [],\n    version: '',\n    nsfw: false,\n    extraPageContent: '',\n    socialHandles: [],\n    chatDisabled: false,\n    externalActions: [],\n    customStyles: '',\n    appearanceVariables: new Map(),\n    maxSocketPayloadSize: 0,\n    federation: {\n      enabled: false,\n      account: '',\n      followerCount: 0,\n    },\n    notifications: {\n      browser: {\n        enabled: false,\n        publicKey: '',\n      },\n    },\n    authentication: {\n      indieAuthEnabled: false,\n    },\n  };\n}\n","import { ClientConfig } from '../interfaces/client-config.model';\n\nconst ENDPOINT = `/api/config`;\n\nclass ClientConfigService {\n  public static async getConfig(): Promise<ClientConfig> {\n    const response = await fetch(ENDPOINT);\n    const status = await response.json();\n    return status;\n  }\n}\n\nexport default ClientConfigService;\n","import { ChatMessage } from '../interfaces/chat-message.model';\nimport { getUnauthedData } from '../utils/apis';\n\nconst ENDPOINT = `/api/chat`;\nconst URL_CHAT_REGISTRATION = `/api/chat/register`;\n\ninterface UserRegistrationResponse {\n  id: string;\n  accessToken: string;\n  displayName: string;\n  displayColor: number;\n}\n\nclass ChatService {\n  public static async getChatHistory(accessToken: string): Promise<ChatMessage[]> {\n    const response = await getUnauthedData(`${ENDPOINT}?accessToken=${accessToken}`);\n    return response;\n  }\n\n  public static async registerUser(username: string): Promise<UserRegistrationResponse> {\n    const options = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ displayName: username }),\n    };\n\n    const response = await getUnauthedData(URL_CHAT_REGISTRATION, options);\n    return response;\n  }\n}\n\nexport default ChatService;\n","import { MessageType, SocketEvent } from '../interfaces/socket-events';\n\nexport interface SocketMessage {\n  type: MessageType;\n  data: any;\n}\n\nexport default class WebsocketService {\n  websocket: WebSocket;\n\n  accessToken: string;\n\n  path: string;\n\n  websocketReconnectTimer: ReturnType<typeof setTimeout>;\n\n  isShutdown = false;\n\n  backOff = 1000;\n\n  handleMessage?: (message: SocketEvent) => void;\n\n  constructor(accessToken, path, host) {\n    this.accessToken = accessToken;\n    this.path = path;\n    this.websocketReconnectTimer = null;\n    this.isShutdown = false;\n\n    this.createAndConnect = this.createAndConnect.bind(this);\n    this.shutdown = this.shutdown.bind(this);\n\n    this.createAndConnect(host);\n  }\n\n  createAndConnect(host) {\n    const url = new URL(host);\n    url.protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    url.pathname = '/ws';\n    url.port = window.location.port === '3000' ? '8080' : window.location.port;\n    url.searchParams.append('accessToken', this.accessToken);\n\n    console.debug('connecting to ', url.toString());\n    const ws = new WebSocket(url.toString());\n    ws.onopen = this.onOpen.bind(this);\n    ws.onerror = this.onError.bind(this);\n    ws.onmessage = this.onMessage.bind(this);\n\n    this.websocket = ws;\n  }\n\n  onOpen() {\n    if (this.websocketReconnectTimer) {\n      clearTimeout(this.websocketReconnectTimer);\n    }\n  }\n\n  // On ws error just close the socket and let it re-connect again for now.\n  onError(e) {\n    handleNetworkingError(`Socket error: ${e}`);\n    this.websocket.close();\n    if (!this.isShutdown) {\n      this.scheduleReconnect();\n    }\n  }\n\n  scheduleReconnect() {\n    if (this.websocketReconnectTimer) {\n      clearTimeout(this.websocketReconnectTimer);\n    }\n    this.backOff *= 2;\n    this.websocketReconnectTimer = setTimeout(\n      this.createAndConnect,\n      5000 + Math.min(this.backOff, 10_000),\n    );\n  }\n\n  shutdown() {\n    this.isShutdown = true;\n    this.websocket.close();\n  }\n\n  /*\n  onMessage is fired when an inbound object comes across the websocket.\n  If the message is of type `PING` we send a `PONG` back and do not\n  pass it along to listeners.\n  */\n  onMessage(e: SocketMessage) {\n    // Optimization where multiple events can be sent within a\n    // single websocket message. So split them if needed.\n    const messages = e.data.split('\\n');\n    let socketEvent: SocketEvent;\n\n    // eslint-disable-next-line no-plusplus\n    for (let i = 0; i < messages.length; i++) {\n      try {\n        socketEvent = JSON.parse(messages[i]);\n        if (this.handleMessage) {\n          this.handleMessage(socketEvent);\n        }\n      } catch (err) {\n        console.error(err, err.data);\n        return;\n      }\n\n      if (!socketEvent.type) {\n        console.error('No type provided', socketEvent);\n        return;\n      }\n\n      // Send PONGs\n      if (socketEvent.type === MessageType.PING) {\n        this.sendPong();\n        return;\n      }\n    }\n  }\n\n  isConnected(): boolean {\n    return this.websocket?.readyState === this.websocket?.OPEN;\n  }\n\n  // Outbound: Other components can pass an object to `send`.\n  send(socketEvent: any) {\n    // Sanity check that what we're sending is a valid type.\n    if (!socketEvent.type || !MessageType[socketEvent.type]) {\n      console.warn(`Outbound message: Unknown socket message type: \"${socketEvent.type}\" sent.`);\n    }\n\n    const messageJSON = JSON.stringify(socketEvent);\n    this.websocket.send(messageJSON);\n  }\n\n  // Reply to a PING as a keep alive.\n  sendPong() {\n    const pong = { type: MessageType.PONG };\n    this.send(pong);\n  }\n}\n\nfunction handleNetworkingError(error) {\n  console.error(\n    `Chat has been disconnected and is likely not working for you. It's possible you were removed from chat. If this is a server configuration issue, visit troubleshooting steps to resolve. https://owncast.online/docs/troubleshooting/#chat-is-disabled: ${error}`,\n  );\n}\n","export interface ServerStatus {\n  online: boolean;\n  viewerCount: number;\n  lastConnectTime?: Date;\n  lastDisconnectTime?: Date;\n  versionNumber?: string;\n  streamTitle?: string;\n  serverTime: Date;\n}\n\nexport function makeEmptyServerStatus(): ServerStatus {\n  return {\n    online: false,\n    viewerCount: 0,\n    serverTime: new Date(),\n  };\n}\n","/*\nThis is a finite state machine model that is used by xstate. https://xstate.js.org/\nYou send events to it and it changes state based on the pre-determined\nmodeling.\nThis allows for a clean and reliable way to model the current state of the\nweb application, and a single place to determine the flow of states.\n\nYou can paste this code into https://stately.ai/viz to see a visual state\nmap or install the VS Code plugin:\nhttps://marketplace.visualstudio.com/items?itemName=statelyai.stately-vscode\n*/\n\nimport { createMachine } from 'xstate';\n\nexport interface AppStateOptions {\n  chatAvailable: boolean;\n  chatLoading?: boolean;\n  videoAvailable: boolean;\n  appLoading?: boolean;\n}\n\nexport function makeEmptyAppState(): AppStateOptions {\n  return {\n    chatAvailable: false,\n    chatLoading: true,\n    videoAvailable: false,\n    appLoading: true,\n  };\n}\n\nconst OFFLINE_STATE: AppStateOptions = {\n  chatAvailable: false,\n  chatLoading: false,\n  videoAvailable: false,\n  appLoading: false,\n};\n\nconst ONLINE_STATE: AppStateOptions = {\n  chatAvailable: true,\n  chatLoading: false,\n  videoAvailable: true,\n  appLoading: false,\n};\n\nconst LOADING_STATE: AppStateOptions = {\n  chatAvailable: false,\n  chatLoading: false,\n  videoAvailable: false,\n  appLoading: true,\n};\n\nconst GOODBYE_STATE: AppStateOptions = {\n  chatAvailable: true,\n  chatLoading: false,\n  videoAvailable: false,\n  appLoading: false,\n};\n\nexport enum AppStateEvent {\n  Loading = 'LOADING', // Have not pulled configuration data from the server.\n  Loaded = 'LOADED', // Configuration data has been pulled from the server.\n  Online = 'ONLINE', // Stream is live\n  Offline = 'OFFLINE', // Stream is not live\n  NeedsRegister = 'NEEDS_REGISTER', // Needs to register a chat user\n  Fail = 'FAIL', // Error\n}\n\nconst appStateModel =\n  /** @xstate-layout N4IgpgJg5mDOIC5QEMAOqDKAXZWwDoAbAe2QgEsA7KAYgCUBRAcQEkMAVBxgEUVFWKxyWcsUp8QAD0QBGAGwz8ABgCscpUoDsAZgAcKgEwrtATgA0IAJ6zNS-CZMLtcuQBY9Jg5t0BfHxbRMHDwiUgpqGgA5BgZuDAB9RlYOLgkBIRExCWkEGRVFVXUtPUNjcytEAxNXfB0DbSNNORMG119-EEDsXAISMipaABkAeQBBbli0wWFRcSQpWQVlNQ0dfSNTC2tc+vwZVwMZWxNbA5kDAz8A9G6QvvDaADFRlkGpjNns2VcCleL1spbRDaA74FS6ORVfYHTSObRXTo3YIEABOYCg5FgeBRA3ozDYnB47xmWXmOQOKj22hUnl02iajjk2iBCCqdgO2n2VRcbQhCK6yPwaIxWLAOIiz1exMyc1A5KMVJpBjpDJczIqCG0enwXk0MiUENMjiUBjk-KRPSFYDIlnwYkIVDANGGj0egxY0WlnzJiF0TXwulU9LqWhMMl0LIM7ipmguIIObU85qClrRNrtADMMw7KE7hpF3Z75ukSbKFgg5Pp7PSQdTXBp9uVtlHtDG464E7okx0BanrRBbVBiMQIAAjSxOyRYy3IDPYgAU2g0y4AlDReyE0wP8EOR+OwF7SXLff7A8ZNCHYeGWedW3qlDIWkz61rLgjKCO4BIN70wgND2W8o3pyyjKrCdZ6q4sYqMmtyouimLYv+xbTDKXyakuyiuHI+QmCoJquCo2FyCyS52PURzqI+mgqIYpqwYKW62vajoAehsJyFS+paPhfoRhqUa6PgTIuLoRznComiEWaPYWpu-bMVmOYHihHxHuWRQ6pCJz0sqGgNMBBjCfohiEUoIJ0kyDF9umu5jhObE+rkqh2BCLS8XhYa6K4wGUuGtEviYZ5qNZ8k2o5x4IJJnGmlUOixoG5kGCy+G1JyXgHGJJhKByrihQQsBigAbmKjzIOQhAAK5ohF5YXJx+q2MYbieFB4KkW0yj6NBfr6vU3n5fglWFSiGblVVNWqaW6H5HY4bNFJbhKI4HV3k0rgnNlS6xm+1wpngtU5NeGoALQXDqbVBct+g5Qofh+EAA */\n  createMachine({\n    id: 'appState',\n    initial: 'loading',\n    predictableActionArguments: true,\n    states: {\n      loading: {\n        meta: LOADING_STATE,\n        on: {\n          NEEDS_REGISTER: {\n            target: 'loading',\n          },\n          LOADED: {\n            target: 'ready',\n          },\n          FAIL: {\n            target: 'serverFailure',\n          },\n        },\n      },\n      ready: {\n        initial: 'offline',\n        states: {\n          online: {\n            meta: {\n              ...ONLINE_STATE,\n            },\n            on: {\n              OFFLINE: {\n                target: 'goodbye',\n              },\n            },\n          },\n          offline: {\n            meta: {\n              ...OFFLINE_STATE,\n            },\n            on: {\n              ONLINE: {\n                target: 'online',\n              },\n            },\n          },\n          goodbye: {\n            on: {\n              ONLINE: {\n                target: 'online',\n              },\n            },\n            meta: {\n              ...GOODBYE_STATE,\n            },\n            after: {\n              '300000': {\n                target: 'offline',\n              },\n            },\n          },\n        },\n      },\n      serverFailure: {\n        type: 'final',\n      },\n      userfailure: {\n        type: 'final',\n      },\n    },\n  });\n\nexport default appStateModel;\n","import { ConnectedClientInfoEvent } from '../../../interfaces/socket-events';\n\nexport function handleConnectedClientInfoMessage(\n  message: ConnectedClientInfoEvent,\n  setChatAuthenticated: (boolean) => void,\n  setCurrentUser: (CurrentUser) => void,\n) {\n  const { user } = message;\n  const { id, displayName, displayColor, scopes, authenticated } = user;\n  setChatAuthenticated(authenticated);\n\n  setCurrentUser({\n    id: id.toString(),\n    displayName,\n    displayColor,\n    isModerator: scopes?.includes('MODERATOR'),\n  });\n}\nexport default handleConnectedClientInfoMessage;\n","import { ServerStatus } from '../interfaces/server-status.model';\n\nconst ENDPOINT = `/api/status`;\n\nclass ServerStatusService {\n  public static async getStatus(): Promise<ServerStatus> {\n    const response = await fetch(ENDPOINT);\n    const status = await response.json();\n    return status;\n  }\n}\n\nexport default ServerStatusService;\n","import { ChatEvent } from '../../../interfaces/socket-events';\n\nexport function handleNameChangeEvent(message: ChatEvent, setChatMessages) {\n  setChatMessages(currentState => [...currentState, message]);\n}\nexport default handleNameChangeEvent;\n","import { FC, useEffect, useState } from 'react';\nimport { atom, selector, useRecoilState, useSetRecoilState, RecoilEnv } from 'recoil';\nimport { useMachine } from '@xstate/react';\nimport { makeEmptyClientConfig, ClientConfig } from '../../interfaces/client-config.model';\nimport ClientConfigService from '../../services/client-config-service';\nimport ChatService from '../../services/chat-service';\nimport WebsocketService from '../../services/websocket-service';\nimport { ChatMessage } from '../../interfaces/chat-message.model';\nimport { CurrentUser } from '../../interfaces/current-user';\nimport { ServerStatus, makeEmptyServerStatus } from '../../interfaces/server-status.model';\nimport appStateModel, {\n  AppStateEvent,\n  AppStateOptions,\n  makeEmptyAppState,\n} from './application-state';\nimport { setLocalStorage, getLocalStorage } from '../../utils/localStorage';\nimport {\n  ConnectedClientInfoEvent,\n  MessageType,\n  ChatEvent,\n  MessageVisibilityEvent,\n  SocketEvent,\n} from '../../interfaces/socket-events';\nimport { mergeMeta } from '../../utils/helpers';\nimport handleConnectedClientInfoMessage from './eventhandlers/connected-client-info-handler';\nimport ServerStatusService from '../../services/status-service';\nimport handleNameChangeEvent from './eventhandlers/handleNameChangeEvent';\nimport { DisplayableError } from '../../types/displayable-error';\n\nRecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = false;\n\nconst SERVER_STATUS_POLL_DURATION = 5000;\nconst ACCESS_TOKEN_KEY = 'accessToken';\n\nlet serverStatusRefreshPoll: ReturnType<typeof setInterval>;\nlet hasBeenModeratorNotified = false;\n\nconst serverConnectivityError = `Cannot connect to the Owncast service. Please check your internet connection or if needed, double check this Owncast server is running.`;\n\n// Server status is what gets updated such as viewer count, durations,\n// stream title, online/offline state, etc.\nexport const serverStatusState = atom<ServerStatus>({\n  key: 'serverStatusState',\n  default: makeEmptyServerStatus(),\n});\n\n// The config that comes from the API.\nexport const clientConfigStateAtom = atom({\n  key: 'clientConfigState',\n  default: makeEmptyClientConfig(),\n});\n\nexport const accessTokenAtom = atom<string>({\n  key: 'accessTokenAtom',\n  default: null,\n});\n\nexport const currentUserAtom = atom<CurrentUser>({\n  key: 'currentUserAtom',\n  default: null,\n});\n\nexport const chatMessagesAtom = atom<ChatMessage[]>({\n  key: 'chatMessages',\n  default: [] as ChatMessage[],\n});\n\nexport const chatAuthenticatedAtom = atom<boolean>({\n  key: 'chatAuthenticatedAtom',\n  default: false,\n});\n\nexport const websocketServiceAtom = atom<WebsocketService>({\n  key: 'websocketServiceAtom',\n  default: null,\n  dangerouslyAllowMutability: true,\n});\n\nexport const appStateAtom = atom<AppStateOptions>({\n  key: 'appState',\n  default: makeEmptyAppState(),\n});\n\nexport const isMobileAtom = atom<boolean | undefined>({\n  key: 'isMobileAtom',\n  default: undefined,\n});\n\nexport const chatVisibleToggleAtom = atom<boolean>({\n  key: 'chatVisibilityToggleAtom',\n  default: true,\n});\n\nexport const isVideoPlayingAtom = atom<boolean>({\n  key: 'isVideoPlayingAtom',\n  default: false,\n});\n\nexport const fatalErrorStateAtom = atom<DisplayableError>({\n  key: 'fatalErrorStateAtom',\n  default: null,\n});\n\nexport const clockSkewAtom = atom<Number>({\n  key: 'clockSkewAtom',\n  default: 0.0,\n});\n\nexport const removedMessageIdsAtom = atom<string[]>({\n  key: 'removedMessageIds',\n  default: [],\n});\n\n// Chat is visible if the user wishes it to be visible AND the required\n// chat state is set.\nexport const isChatVisibleSelector = selector({\n  key: 'isChatVisibleSelector',\n  get: ({ get }) => {\n    const state: AppStateOptions = get(appStateAtom);\n    const userVisibleToggle: boolean = get(chatVisibleToggleAtom);\n    const accessToken: string = get(accessTokenAtom);\n    return accessToken && state.chatAvailable && userVisibleToggle;\n  },\n});\n\nexport const isChatAvailableSelector = selector({\n  key: 'isChatAvailableSelector',\n  get: ({ get }) => {\n    const state: AppStateOptions = get(appStateAtom);\n    const accessToken: string = get(accessTokenAtom);\n    return accessToken && state.chatAvailable;\n  },\n});\n\n// We display in an \"online/live\" state as long as video is actively playing.\n// Even during the time where technically the server has said it's no longer\n// live, however the last few seconds of video playback is still taking place.\nexport const isOnlineSelector = selector({\n  key: 'isOnlineSelector',\n  get: ({ get }) => {\n    const state: AppStateOptions = get(appStateAtom);\n    const isVideoPlaying: boolean = get(isVideoPlayingAtom);\n    return state.videoAvailable || isVideoPlaying;\n  },\n});\n\nexport const visibleChatMessagesSelector = selector<ChatMessage[]>({\n  key: 'visibleChatMessagesSelector',\n  get: ({ get }) => {\n    const messages: ChatMessage[] = get(chatMessagesAtom);\n    const removedIds: string[] = get(removedMessageIdsAtom);\n    return messages.filter(message => !removedIds.includes(message.id));\n  },\n});\n\nexport const ClientConfigStore: FC = () => {\n  const [appState, appStateSend, appStateService] = useMachine(appStateModel);\n  const [currentUser, setCurrentUser] = useRecoilState(currentUserAtom);\n  const setChatAuthenticated = useSetRecoilState<boolean>(chatAuthenticatedAtom);\n  const [clientConfig, setClientConfig] = useRecoilState<ClientConfig>(clientConfigStateAtom);\n  const [serverStatus, setServerStatus] = useRecoilState<ServerStatus>(serverStatusState);\n  const setClockSkew = useSetRecoilState<Number>(clockSkewAtom);\n  const [chatMessages, setChatMessages] = useRecoilState<ChatMessage[]>(chatMessagesAtom);\n  const [accessToken, setAccessToken] = useRecoilState<string>(accessTokenAtom);\n  const setAppState = useSetRecoilState<AppStateOptions>(appStateAtom);\n  const setGlobalFatalErrorMessage = useSetRecoilState<DisplayableError>(fatalErrorStateAtom);\n  const setWebsocketService = useSetRecoilState<WebsocketService>(websocketServiceAtom);\n  const [hiddenMessageIds, setHiddenMessageIds] = useRecoilState<string[]>(removedMessageIdsAtom);\n  const [, setHasLoadedStatus] = useState(false);\n  const [hasLoadedConfig, setHasLoadedConfig] = useState(false);\n\n  let ws: WebsocketService;\n\n  const setGlobalFatalError = (title: string, message: string) => {\n    setGlobalFatalErrorMessage({\n      title,\n      message,\n    });\n  };\n  const sendEvent = (event: string) => {\n    // console.debug('---- sending event:', event);\n    appStateSend({ type: event });\n  };\n\n  const handleStatusChange = (status: ServerStatus) => {\n    if (appState.matches('loading')) {\n      sendEvent(AppStateEvent.Loaded);\n      return;\n    }\n\n    if (status.online && appState.matches('ready')) {\n      sendEvent(AppStateEvent.Online);\n    } else if (!status.online && !appState.matches('ready.offline')) {\n      sendEvent(AppStateEvent.Offline);\n    }\n  };\n\n  const updateClientConfig = async () => {\n    try {\n      const config = await ClientConfigService.getConfig();\n      setClientConfig(config);\n      setGlobalFatalErrorMessage(null);\n      setHasLoadedConfig(true);\n    } catch (error) {\n      setGlobalFatalError('Unable to reach Owncast server', serverConnectivityError);\n      console.error(`ClientConfigService -> getConfig() ERROR: \\n${error}`);\n    }\n  };\n\n  const updateServerStatus = async () => {\n    try {\n      const status = await ServerStatusService.getStatus();\n      setServerStatus(status);\n      setHasLoadedStatus(true);\n      const { serverTime } = status;\n\n      const clockSkew = new Date(serverTime).getTime() - Date.now();\n      setClockSkew(clockSkew);\n\n      setGlobalFatalErrorMessage(null);\n    } catch (error) {\n      sendEvent(AppStateEvent.Fail);\n      setGlobalFatalError('Unable to reach Owncast server', serverConnectivityError);\n      console.error(`serverStatusState -> getStatus() ERROR: \\n${error}`);\n    }\n  };\n\n  const handleUserRegistration = async (optionalDisplayName?: string) => {\n    const savedAccessToken = getLocalStorage(ACCESS_TOKEN_KEY);\n    if (savedAccessToken) {\n      setAccessToken(savedAccessToken);\n      return;\n    }\n\n    try {\n      sendEvent(AppStateEvent.NeedsRegister);\n      const response = await ChatService.registerUser(optionalDisplayName);\n      const { accessToken: newAccessToken, displayName: newDisplayName, displayColor } = response;\n      if (!newAccessToken) {\n        return;\n      }\n\n      setCurrentUser({\n        ...currentUser,\n        displayName: newDisplayName,\n        displayColor,\n      });\n      setAccessToken(newAccessToken);\n      setLocalStorage(ACCESS_TOKEN_KEY, newAccessToken);\n    } catch (e) {\n      sendEvent(AppStateEvent.Fail);\n      console.error(`ChatService -> registerUser() ERROR: \\n${e}`);\n    }\n  };\n\n  const resetAndReAuth = () => {\n    setLocalStorage(ACCESS_TOKEN_KEY, '');\n    setAccessToken(null);\n    handleUserRegistration();\n  };\n\n  const handleMessageVisibilityChange = (message: MessageVisibilityEvent) => {\n    const { ids, visible } = message;\n    if (visible) {\n      const updatedIds = hiddenMessageIds.filter(id => !ids.includes(id));\n      setHiddenMessageIds(updatedIds);\n    } else {\n      const updatedIds = [...hiddenMessageIds, ...ids];\n      setHiddenMessageIds(updatedIds);\n    }\n  };\n\n  const handleMessage = (message: SocketEvent) => {\n    switch (message.type) {\n      case MessageType.ERROR_NEEDS_REGISTRATION:\n        resetAndReAuth();\n        break;\n      case MessageType.CONNECTED_USER_INFO:\n        handleConnectedClientInfoMessage(\n          message as ConnectedClientInfoEvent,\n          setChatAuthenticated,\n          setCurrentUser,\n        );\n        if (!hasBeenModeratorNotified) {\n          setChatMessages(currentState => [...currentState, message as ChatEvent]);\n          hasBeenModeratorNotified = true;\n        }\n        break;\n      case MessageType.CHAT:\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.NAME_CHANGE:\n        handleNameChangeEvent(message as ChatEvent, setChatMessages);\n        break;\n      case MessageType.USER_JOINED:\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.SYSTEM:\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.CHAT_ACTION:\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.VISIBILITY_UPDATE:\n        handleMessageVisibilityChange(message as MessageVisibilityEvent);\n        break;\n      default:\n        console.error('Unknown socket message type: ', message.type);\n    }\n  };\n\n  const getChatHistory = async () => {\n    try {\n      const messages = await ChatService.getChatHistory(accessToken);\n      setChatMessages(currentState => [...currentState, ...messages]);\n    } catch (error) {\n      console.error(`ChatService -> getChatHistory() ERROR: \\n${error}`);\n    }\n  };\n\n  const startChat = async () => {\n    try {\n      const { socketHostOverride } = clientConfig;\n\n      // Get a copy of the browser location without #fragments.\n      const l = window.location;\n      l.hash = '';\n      const location = l.toString().replaceAll('#', '');\n      const host = socketHostOverride || location;\n\n      ws = new WebsocketService(accessToken, '/ws', host);\n      ws.handleMessage = handleMessage;\n      setWebsocketService(ws);\n    } catch (error) {\n      console.error(`ChatService -> startChat() ERROR: \\n${error}`);\n    }\n  };\n\n  const handleChatNotification = () => {};\n\n  // Read the config and status on initial load from a JSON string that lives\n  // in window. This is placed there server-side and allows for fast initial\n  // load times because we don't have to wait for the API calls to complete.\n  useEffect(() => {\n    try {\n      if ((window as any).configHydration) {\n        const config = JSON.parse((window as any).configHydration);\n        setClientConfig(config);\n        setHasLoadedConfig(true);\n      }\n    } catch (e) {\n      console.error('Error parsing config hydration', e);\n    }\n\n    try {\n      if ((window as any).statusHydration) {\n        const status = JSON.parse((window as any).statusHydration);\n        setServerStatus(status);\n        setHasLoadedStatus(true);\n      }\n    } catch (e) {\n      console.error('error parsing status hydration', e);\n    }\n  }, []);\n\n  useEffect(() => {\n    handleStatusChange(serverStatus);\n  }, [serverStatus]);\n\n  useEffect(() => {\n    if (!clientConfig.chatDisabled && accessToken && hasLoadedConfig) {\n      startChat();\n    }\n  }, [hasLoadedConfig, accessToken]);\n\n  // Notify about chat activity when backgrounded.\n  useEffect(() => {\n    handleChatNotification();\n  }, [chatMessages]);\n\n  useEffect(() => {\n    updateClientConfig();\n    handleUserRegistration();\n    updateServerStatus();\n\n    clearInterval(serverStatusRefreshPoll);\n    serverStatusRefreshPoll = setInterval(() => {\n      updateServerStatus();\n    }, SERVER_STATUS_POLL_DURATION);\n\n    return () => {\n      clearInterval(serverStatusRefreshPoll);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (accessToken) {\n      getChatHistory();\n    }\n  }, [accessToken]);\n\n  useEffect(() => {\n    appStateService.onTransition(state => {\n      const metadata = mergeMeta(state.meta) as AppStateOptions;\n\n      // console.debug('--- APP STATE: ', state.value);\n      // console.debug('--- APP META: ', metadata);\n\n      setAppState(metadata);\n    });\n  }, []);\n\n  return null;\n};\n","import { User } from './user.model';\n\nexport enum MessageType {\n  CHAT = 'CHAT',\n  PING = 'PING',\n  NAME_CHANGE = 'NAME_CHANGE',\n  COLOR_CHANGE = 'COLOR_CHANGE',\n  PONG = 'PONG',\n  SYSTEM = 'SYSTEM',\n  USER_JOINED = 'USER_JOINED',\n  CHAT_ACTION = 'CHAT_ACTION',\n  FEDIVERSE_ENGAGEMENT_FOLLOW = 'FEDIVERSE_ENGAGEMENT_FOLLOW',\n  FEDIVERSE_ENGAGEMENT_LIKE = 'FEDIVERSE_ENGAGEMENT_LIKE',\n  FEDIVERSE_ENGAGEMENT_REPOST = 'FEDIVERSE_ENGAGEMENT_REPOST',\n  CONNECTED_USER_INFO = 'CONNECTED_USER_INFO',\n  ERROR_USER_DISABLED = 'ERROR_USER_DISABLED',\n  ERROR_NEEDS_REGISTRATION = 'ERROR_NEEDS_REGISTRATION',\n  ERROR_MAX_CONNECTIONS_EXCEEDED = 'ERROR_MAX_CONNECTIONS_EXCEEDED',\n  VISIBILITY_UPDATE = 'VISIBILITY-UPDATE',\n}\n\nexport interface SocketEvent {\n  id: string;\n  timestamp: Date;\n  type: MessageType;\n}\n\nexport interface ConnectedClientInfoEvent extends SocketEvent {\n  user: User;\n}\nexport interface ChatEvent extends SocketEvent {\n  user: User;\n  body: string;\n}\n\nexport interface NameChangeEvent extends SocketEvent {\n  user: User;\n  oldName: string;\n}\n\nexport interface MessageVisibilityEvent extends SocketEvent {\n  visible: boolean;\n  ids: string[];\n}\n","// convert newlines to <br>s\nexport function addNewlines(str) {\n  return str.replace(/(?:\\r\\n|\\r|\\n)/g, '<br />');\n}\n\nexport function pluralize(string, count) {\n  if (count === 1) {\n    return string;\n  }\n  return `${string}s`;\n}\n\n// Trying to determine if browser is mobile/tablet.\n// Source: https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\nexport function hasTouchScreen() {\n  let hasTouch = false;\n  if ('maxTouchPoints' in navigator) {\n    hasTouch = navigator.maxTouchPoints > 0;\n  } else if ('msMaxTouchPoints' in navigator) {\n    hasTouch = navigator.msMaxTouchPoints > 0;\n  } else {\n    const mQ = window.matchMedia && matchMedia('(pointer:coarse)');\n    if (mQ && mQ.media === '(pointer:coarse)') {\n      hasTouch = !!mQ.matches;\n    } else if ('orientation' in window) {\n      hasTouch = true; // deprecated, but good fallback\n    } else {\n      // Only as a last resort, fall back to user agent sniffing\n      hasTouch = navigator.userAgentData.mobile;\n    }\n  }\n  return hasTouch;\n}\n\nexport function padLeft(text, pad, size) {\n  return String(pad.repeat(size) + text).slice(-size);\n}\n\nexport function parseSecondsToDurationString(seconds = 0) {\n  const finiteSeconds = Number.isFinite(+seconds) ? Math.abs(seconds) : 0;\n\n  const days = Math.floor(finiteSeconds / 86400);\n  const daysString = days > 0 ? `${days} day${days > 1 ? 's' : ''} ` : '';\n\n  const hours = Math.floor((finiteSeconds / 3600) % 24);\n  const hoursString = hours || days ? padLeft(`${hours}:`, '0', 3) : '';\n\n  const mins = Math.floor((finiteSeconds / 60) % 60);\n  const minString = padLeft(`${mins}:`, '0', 3);\n\n  const secs = Math.floor(finiteSeconds % 60);\n  const secsString = padLeft(`${secs}`, '0', 2);\n\n  return daysString + hoursString + minString + secsString;\n}\n\nexport function setVHvar() {\n  const vh = window.innerHeight * 0.01;\n  // Then we set the value in the --vh custom property to the root of the document\n  document.documentElement.style.setProperty('--vh', `${vh}px`);\n}\n\nexport function doesObjectSupportFunction(object, functionName) {\n  return typeof object[functionName] === 'function';\n}\n\n// return a string of css classes\nexport function classNames(json) {\n  const classes = [];\n\n  Object.entries(json).map(item => {\n    const [key, value] = item;\n    if (value) {\n      classes.push(key);\n    }\n    return null;\n  });\n  return classes.join(' ');\n}\n\n// taken from\n// https://medium.com/@TCAS3/debounce-deep-dive-javascript-es6-e6f8d983b7a1\nexport function debounce(fn, time) {\n  let timeout;\n\n  return function () {\n    // eslint-disable-next-line prefer-rest-params\n    const functionCall = () => fn.apply(this, arguments);\n\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n}\n\nexport function getDiffInDaysFromNow(timestamp) {\n  const time = typeof timestamp === 'string' ? new Date(timestamp) : timestamp;\n  return (new Date() - time) / (24 * 3600 * 1000);\n}\n\n// \"Last live today at [time]\" or \"last live [date]\"\nexport function makeLastOnlineString(timestamp) {\n  if (!timestamp) {\n    return '';\n  }\n  let string = '';\n  const time = new Date(timestamp);\n  const comparisonDate = new Date(time).setHours(0, 0, 0, 0);\n\n  if (comparisonDate === new Date().setHours(0, 0, 0, 0)) {\n    const atTime = time.toLocaleTimeString([], {\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n    string = `Today ${atTime}`;\n  } else {\n    string = time.toLocaleDateString();\n  }\n\n  return `Last live: ${string}`;\n}\n\n// Routing & Tabs\nexport const ROUTE_RECORDINGS = 'recordings';\nexport const ROUTE_SCHEDULE = 'schedule';\n// looks for `/recording|schedule/id` pattern to determine what to display from the tab view\nexport function checkUrlPathForDisplay() {\n  const pathTest = [ROUTE_RECORDINGS, ROUTE_SCHEDULE];\n  const pathParts = window.location.pathname.split('/');\n\n  if (pathParts.length >= 2) {\n    const part = pathParts[1].toLowerCase();\n    if (pathTest.includes(part)) {\n      return {\n        section: part,\n        sectionId: pathParts[2] || '',\n      };\n    }\n  }\n  return null;\n}\n\nexport function paginateArray(items, page, perPage) {\n  const offset = perPage * (page - 1);\n  const totalPages = Math.ceil(items.length / perPage);\n  const paginatedItems = items.slice(offset, perPage * page);\n\n  return {\n    previousPage: page - 1 ? page - 1 : null,\n    nextPage: totalPages > page ? page + 1 : null,\n    total: items.length,\n    totalPages,\n    items: paginatedItems,\n  };\n}\n\n// Take a nested object of state metadata and merge it into\n// a single flattened node.\nexport function mergeMeta(meta) {\n  return Object.keys(meta).reduce((acc, key) => {\n    const value = meta[key];\n    Object.assign(acc, value);\n\n    return acc;\n  }, {});\n}\n","export const LOCAL_STORAGE_KEYS = {\n  username: 'username',\n  hasDisplayedNotificationModal: 'HAS_DISPLAYED_NOTIFICATION_MODAL',\n  userVisitCount: 'USER_VISIT_COUNT',\n};\n\nexport function getLocalStorage(key) {\n  try {\n    return localStorage.getItem(key);\n  } catch (e) {}\n  return null;\n}\n\nexport function setLocalStorage(key, value) {\n  try {\n    if (value !== '' && value !== null) {\n      localStorage.setItem(key, value);\n    } else {\n      localStorage.removeItem(key);\n    }\n    return true;\n  } catch (e) {}\n  return false;\n}\n\nexport function clearLocalStorage(key) {\n  localStorage.removeItem(key);\n}\n\n// jump down to the max height of a div, with a slight delay\nexport function jumpToBottom(element, behavior) {\n  if (!element) return;\n\n  if (!behavior) {\n    behavior = document.visibilityState === 'visible' ? 'smooth' : 'instant';\n  }\n\n  setTimeout(\n    () => {\n      element.scrollTo({\n        top: element.scrollHeight,\n        left: 0,\n        behavior,\n      });\n    },\n    50,\n    element,\n  );\n}\n"],"names":["serverStatusRefreshPoll","AppStateEvent","client_config_service","getConfig","response","fetch","status","json","chat_service","getChatHistory","accessToken","getUnauthedData","concat","registerUser","username","options","method","headers","body","JSON","stringify","displayName","WebsocketService","createAndConnect","host","url","URL","protocol","window","location","pathname","port","searchParams","append","console","debug","toString","ws","WebSocket","onopen","onOpen","bind","onerror","onError","onmessage","onMessage","websocket","websocketReconnectTimer","clearTimeout","e","error","close","isShutdown","scheduleReconnect","backOff","setTimeout","Math","min","shutdown","socketEvent","messages","data","split","i","length","parse","handleMessage","err","type","MessageType","sendPong","isConnected","_this_websocket","_this_websocket1","readyState","OPEN","send","warn","messageJSON","pong","constructor","path","Loading","Loaded","Online","Offline","NeedsRegister","Fail","appStateModel","createMachine","id","initial","predictableActionArguments","states","loading","meta","chatAvailable","chatLoading","videoAvailable","appLoading","on","NEEDS_REGISTER","target","LOADED","FAIL","ready","online","OFFLINE","offline","ONLINE","goodbye","after","serverFailure","userfailure","connected_client_info_handler","message","setChatAuthenticated","setCurrentUser","user","displayColor","scopes","authenticated","isModerator","includes","status_service","getStatus","eventhandlers_handleNameChangeEvent","setChatMessages","currentState","RecoilEnv","ACCESS_TOKEN_KEY","hasBeenModeratorNotified","serverConnectivityError","serverStatusState","atom","key","default","viewerCount","serverTime","Date","clientConfigStateAtom","name","summary","offlineMessage","logo","tags","version","nsfw","extraPageContent","socialHandles","chatDisabled","externalActions","customStyles","appearanceVariables","Map","maxSocketPayloadSize","federation","enabled","account","followerCount","notifications","browser","publicKey","authentication","indieAuthEnabled","accessTokenAtom","currentUserAtom","chatMessagesAtom","chatAuthenticatedAtom","websocketServiceAtom","dangerouslyAllowMutability","appStateAtom","isMobileAtom","undefined","chatVisibleToggleAtom","isVideoPlayingAtom","fatalErrorStateAtom","clockSkewAtom","removedMessageIdsAtom","isChatVisibleSelector","selector","get","param","state","userVisibleToggle","isChatAvailableSelector","isOnlineSelector","isVideoPlaying","visibleChatMessagesSelector","removedIds","filter","ClientConfigStore","appState","appStateSend","appStateService","useMachine","currentUser","useRecoilState","useSetRecoilState","clientConfig","setClientConfig","serverStatus","setServerStatus","setClockSkew","chatMessages","setAccessToken","setAppState","setGlobalFatalErrorMessage","setWebsocketService","hiddenMessageIds","setHiddenMessageIds","setHasLoadedStatus","useState","hasLoadedConfig","setHasLoadedConfig","setGlobalFatalError","title","sendEvent","event","handleStatusChange","matches","updateClientConfig","config","ClientConfigService","updateServerStatus","ServerStatusService","clockSkew","getTime","now","handleUserRegistration","optionalDisplayName","savedAccessToken","getLocalStorage","ChatService","newAccessToken","newDisplayName","setLocalStorage","resetAndReAuth","handleMessageVisibilityChange","ids","visible","updatedIds","handleConnectedClientInfoMessage","handleNameChangeEvent","startChat","socketHostOverride","l","hash","replaceAll","handleChatNotification","useEffect","configHydration","statusHydration","clearInterval","setInterval","onTransition","metadata","mergeMeta","CHAT","PING","NAME_CHANGE","COLOR_CHANGE","PONG","SYSTEM","USER_JOINED","CHAT_ACTION","FEDIVERSE_ENGAGEMENT_FOLLOW","FEDIVERSE_ENGAGEMENT_LIKE","FEDIVERSE_ENGAGEMENT_REPOST","CONNECTED_USER_INFO","ERROR_USER_DISABLED","ERROR_NEEDS_REGISTRATION","ERROR_MAX_CONNECTIONS_EXCEEDED","VISIBILITY_UPDATE","getDiffInDaysFromNow","timestamp","time","Object","keys","reduce","acc","value","assign","LOCAL_STORAGE_KEYS","hasDisplayedNotificationModal","userVisitCount","localStorage","getItem","setItem","removeItem"],"sourceRoot":""}