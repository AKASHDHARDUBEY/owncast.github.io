{"version":3,"file":"static/chunks/7663.21b5f4736a0d24b7.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/fcl.js","webpack://_N_E/<anon>"],"sourcesContent":["var keywords = {\n  \"term\": true,\n  \"method\": true, \"accu\": true,\n  \"rule\": true, \"then\": true, \"is\": true, \"and\": true, \"or\": true,\n  \"if\": true, \"default\": true\n};\n\nvar start_blocks = {\n  \"var_input\": true,\n  \"var_output\": true,\n  \"fuzzify\": true,\n  \"defuzzify\": true,\n  \"function_block\": true,\n  \"ruleblock\": true\n};\n\nvar end_blocks = {\n  \"end_ruleblock\": true,\n  \"end_defuzzify\": true,\n  \"end_function_block\": true,\n  \"end_fuzzify\": true,\n  \"end_var\": true\n};\n\nvar atoms = {\n  \"true\": true, \"false\": true, \"nan\": true,\n  \"real\": true, \"min\": true, \"max\": true, \"cog\": true, \"cogs\": true\n};\n\nvar isOperatorChar = /[+\\-*&^%:=<>!|\\/]/;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n\n  if (/[\\d\\.]/.test(ch)) {\n    if (ch == \".\") {\n      stream.match(/^[0-9]+([eE][\\-+]?[0-9]+)?/);\n    } else if (ch == \"0\") {\n      stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);\n    } else {\n      stream.match(/^[0-9]*\\.?[0-9]*([eE][\\-+]?[0-9]+)?/);\n    }\n    return \"number\";\n  }\n\n  if (ch == \"/\" || ch == \"(\") {\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n  stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n\n  var cur = stream.current().toLowerCase();\n  if (keywords.propertyIsEnumerable(cur) ||\n      start_blocks.propertyIsEnumerable(cur) ||\n      end_blocks.propertyIsEnumerable(cur)) {\n    return \"keyword\";\n  }\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  return \"variable\";\n}\n\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if ((ch == \"/\" || ch == \")\") && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction Context(indented, column, type, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.align = align;\n  this.prev = prev;\n}\n\nfunction pushContext(state, col, type) {\n  return state.context = new Context(state.indented, col, type, null, state.context);\n}\n\nfunction popContext(state) {\n  if (!state.context.prev) return;\n  var t = state.context.type;\n  if (t == \"end_block\")\n    state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\n// Interface\n\nexport const fcl = {\n  name: \"fcl\",\n  startState: function(indentUnit) {\n    return {\n      tokenize: null,\n      context: new Context(-indentUnit, 0, \"top\", false),\n      indented: 0,\n      startOfLine: true\n    };\n  },\n\n  token: function(stream, state) {\n    var ctx = state.context;\n    if (stream.sol()) {\n      if (ctx.align == null) ctx.align = false;\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n    }\n    if (stream.eatSpace()) return null;\n\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\") return style;\n    if (ctx.align == null) ctx.align = true;\n\n    var cur = stream.current().toLowerCase();\n\n    if (start_blocks.propertyIsEnumerable(cur)) pushContext(state, stream.column(), \"end_block\");\n    else if (end_blocks.propertyIsEnumerable(cur))  popContext(state);\n\n    state.startOfLine = false;\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != tokenBase && state.tokenize != null) return 0;\n    var ctx = state.context;\n\n    var closing = end_blocks.propertyIsEnumerable(textAfter);\n    if (ctx.align) return ctx.column + (closing ? 0 : 1);\n    else return ctx.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    commentTokens: {line: \"//\", block: {open: \"(*\", close: \"*)\"}}\n  }\n};\n\n"],"names":["keywords","start_blocks","end_blocks","atoms","isOperatorChar","tokenBase","stream","state","ch","next","test","match","eat","tokenize","tokenComment","skipToEnd","eatWhile","cur","current","toLowerCase","propertyIsEnumerable","maybeEnd","Context","indented","column","type","align","prev","fcl","name","startState","indentUnit","context","startOfLine","token","col","ctx","sol","indentation","eatSpace","style","indent","textAfter","cx","closing","unit","languageData","commentTokens","line","block","open","close"],"sourceRoot":""}