{"version":3,"file":"static/chunks/2602.36ff448ed6ccd55c.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/crystal.js","webpack://_N_E/<anon>"],"sourcesContent":["function wordRegExp(words, end) {\n  return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\n\nfunction chain(tokenize, stream, state) {\n  state.tokenize.push(tokenize);\n  return tokenize(stream, state);\n}\n\nvar operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar indexingOperators = /^(?:\\[\\][?=]?)/;\nvar anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar keywords = wordRegExp([\n  \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n  \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\",\n  \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n  \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\",\n  \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n  \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"\n]);\nvar atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\nvar indentKeywordsArray = [\n  \"def\", \"fun\", \"macro\",\n  \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n  \"do\", \"for\"\n];\nvar indentKeywords = wordRegExp(indentKeywordsArray);\nvar indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\nvar indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\nvar dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\nvar dedentKeywords = wordRegExp(dedentKeywordsArray);\nvar dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\nvar dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\nvar nextTokenizer = {\n  \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n  \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n  \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n};\nvar matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Macros\n  if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n    return chain(tokenMacro(\"%\", \"%\"), stream, state);\n  }\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n    return chain(tokenMacro(\"{\", \"}\"), stream, state);\n  }\n\n  // Comments\n  if (stream.peek() == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Variables and keywords\n  var matched;\n  if (stream.match(idents)) {\n    stream.eat(/[?!]/);\n\n    matched = stream.current();\n    if (stream.eat(\":\")) {\n      return \"atom\";\n    } else if (state.lastToken == \".\") {\n      return \"property\";\n    } else if (keywords.test(matched)) {\n      if (indentKeywords.test(matched)) {\n        if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n          state.blocks.push(matched);\n          state.currentIndent += 1;\n        }\n      } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n        state.blocks.push(matched);\n        state.currentIndent += 1;\n      } else if (matched == \"end\") {\n        state.blocks.pop();\n        state.currentIndent -= 1;\n      }\n\n      if (nextTokenizer.hasOwnProperty(matched)) {\n        state.tokenize.push(nextTokenizer[matched]);\n      }\n\n      return \"keyword\";\n    } else if (atomWords.test(matched)) {\n      return \"atom\";\n    }\n\n    return \"variable\";\n  }\n\n  // Class variables and instance variables\n  // or attributes\n  if (stream.eat(\"@\")) {\n    if (stream.peek() == \"[\") {\n      return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n    }\n\n    stream.eat(\"@\");\n    stream.match(idents) || stream.match(types);\n    return \"propertyName\";\n  }\n\n  // Constants and types\n  if (stream.match(types)) {\n    return \"tag\";\n  }\n\n  // Symbols or ':' operator\n  if (stream.eat(\":\")) {\n    if (stream.eat(\"\\\"\")) {\n      return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n    } else if (stream.match(idents) || stream.match(types) ||\n               stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n      return \"atom\";\n    }\n    stream.eat(\":\");\n    return \"operator\";\n  }\n\n  // Strings\n  if (stream.eat(\"\\\"\")) {\n    return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n  }\n\n  // Strings or regexps or macro variables or '%' operator\n  if (stream.peek() == \"%\") {\n    var style = \"string\";\n    var embed = true;\n    var delim;\n\n    if (stream.match(\"%r\")) {\n      // Regexps\n      style = \"string.special\";\n      delim = stream.next();\n    } else if (stream.match(\"%w\")) {\n      embed = false;\n      delim = stream.next();\n    } else if (stream.match(\"%q\")) {\n      embed = false;\n      delim = stream.next();\n    } else {\n      if(delim = stream.match(/^%([^\\w\\s=])/)) {\n        delim = delim[1];\n      } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n        // Macro variables\n        return \"meta\";\n      } else if (stream.eat('%')) {\n        // '%' operator\n        return \"operator\";\n      }\n    }\n\n    if (matching.hasOwnProperty(delim)) {\n      delim = matching[delim];\n    }\n    return chain(tokenQuote(delim, style, embed), stream, state);\n  }\n\n  // Here Docs\n  if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n    return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)\n  }\n\n  // Characters\n  if (stream.eat(\"'\")) {\n    stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n    stream.eat(\"'\");\n    return \"atom\";\n  }\n\n  // Numbers\n  if (stream.eat(\"0\")) {\n    if (stream.eat(\"x\")) {\n      stream.match(/^[0-9a-fA-F_]+/);\n    } else if (stream.eat(\"o\")) {\n      stream.match(/^[0-7_]+/);\n    } else if (stream.eat(\"b\")) {\n      stream.match(/^[01_]+/);\n    }\n    return \"number\";\n  }\n\n  if (stream.eat(/^\\d/)) {\n    stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n    return \"number\";\n  }\n\n  // Operators\n  if (stream.match(operators)) {\n    stream.eat(\"=\"); // Operators can follow assign symbol.\n    return \"operator\";\n  }\n\n  if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n    return \"operator\";\n  }\n\n  // Parens and braces\n  if (matched = stream.match(/[({[]/, false)) {\n    matched = matched[0];\n    return chain(tokenNest(matched, matching[matched], null), stream, state);\n  }\n\n  // Escapes\n  if (stream.eat(\"\\\\\")) {\n    stream.next();\n    return \"meta\";\n  }\n\n  stream.next();\n  return null;\n}\n\nfunction tokenNest(begin, end, style, started) {\n  return function (stream, state) {\n    if (!started && stream.match(begin)) {\n      state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n      state.currentIndent += 1;\n      return style;\n    }\n\n    var nextStyle = tokenBase(stream, state);\n    if (stream.current() === end) {\n      state.tokenize.pop();\n      state.currentIndent -= 1;\n      nextStyle = style;\n    }\n\n    return nextStyle;\n  };\n}\n\nfunction tokenMacro(begin, end, started) {\n  return function (stream, state) {\n    if (!started && stream.match(\"{\" + begin)) {\n      state.currentIndent += 1;\n      state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n      return \"meta\";\n    }\n\n    if (stream.match(end + \"}\")) {\n      state.currentIndent -= 1;\n      state.tokenize.pop();\n      return \"meta\";\n    }\n\n    return tokenBase(stream, state);\n  };\n}\n\nfunction tokenMacroDef(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var matched;\n  if (matched = stream.match(idents)) {\n    if (matched == \"def\") {\n      return \"keyword\";\n    }\n    stream.eat(/[?!]/);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowIdent(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if (stream.match(idents)) {\n    stream.eat(/[!?]/);\n  } else {\n    stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n  }\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowType(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(types);\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenQuote(end, style, embed) {\n  return function (stream, state) {\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return style;\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return style;\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return style;\n        }\n\n        var ch = stream.next();\n\n        if (ch == end) {\n          state.tokenize.pop();\n          return style;\n        }\n\n        escaped = embed && ch == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return style;\n  };\n}\n\nfunction tokenHereDoc(phrase, embed) {\n  return function (stream, state) {\n    if (stream.sol()) {\n      stream.eatSpace()\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n        return \"string\";\n      }\n    }\n\n    var escaped = false;\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return \"string\";\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return \"string\";\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return \"string\";\n        }\n\n        escaped = embed && stream.next() == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return \"string\";\n  }\n}\n\nexport const crystal = {\n  name: \"crystal\",\n  startState: function () {\n    return {\n      tokenize: [tokenBase],\n      currentIndent: 0,\n      lastToken: null,\n      lastStyle: null,\n      blocks: []\n    };\n  },\n\n  token: function (stream, state) {\n    var style = state.tokenize[state.tokenize.length - 1](stream, state);\n    var token = stream.current();\n\n    if (style && style != \"comment\") {\n      state.lastToken = token;\n      state.lastStyle = style;\n    }\n\n    return style;\n  },\n\n  indent: function (state, textAfter, cx) {\n    textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n    if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n      return cx.unit * (state.currentIndent - 1);\n    }\n\n    return cx.unit * state.currentIndent;\n  },\n\n  languageData: {\n    indentOnInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"names":["wordRegExp","words","end","join","chain","tokenize","stream","state","push","operators","conditionalOperators","indexingOperators","anotherOperators","idents","types","keywords","atomWords","indentKeywords","indentExpressionKeywords","dedentKeywordsArray","dedentKeywords","dedentPunctualsArray","dedentPunctuals","nextTokenizer","tokenFollowIdent","matched","eatSpace","match","eat","pop","tokenFollowType","matching","tokenBase","lastToken","tokenMacro","peek","skipToEnd","current","test","blocks","indexOf","currentIndent","lastStyle","hasOwnProperty","tokenNest","tokenQuote","phrase","embed","delim","style","next","sol","escaped","begin","started","length","nextStyle","ch","crystal","name","startState","token","indent","textAfter","cx","replace","unit","languageData","indentOnInput","concat","commentTokens","line"],"sourceRoot":""}