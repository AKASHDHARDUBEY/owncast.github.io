{"version":3,"file":"static/chunks/6062.c65c3da75364cd39.js","mappings":"mGAAA,SAAAA,EAAAC,CAAA,EAEA,QADAC,EAAA,GACAC,EAAA,EAAkBA,EAAAF,EAAAG,MAAA,CAAkBD,IAAAD,CAAA,CAAAD,CAAA,CAAAE,EAAA,KACpC,OAAAD,CACA,4CAEA,IAAAG,EAAAL,EAAA,qHACA,+GACA,mIACA,mHACA,yKACA,wHACA,6GACAM,EAAAN,EAAA,yHACAO,EAAAP,EAAA,2CACAQ,EAAAR,EAAA,iIACA,4CAGAS,EAAA,mBACAC,EAAA,qBACAC,EAAA,gFACAC,EAAA,kDACAC,EAAA,uCACAC,EAAA,6CACAC,EAAA,eACAC,EAAA,4CAGA,SAAAC,EAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EAEA,GADAF,EAAAG,GAAA,IAAAF,CAAAA,EAAAG,QAAA,CAAAJ,EAAAK,WAAA,IACAL,EAAAM,QAAA,eAEA,IA2BAC,EA3BAC,EAAAR,EAAAS,IAAA,GACA,GAAAD,KAAAA,EAAA,CACA,GAAAR,EAAAU,KAAA,OAEA,OADAV,EAAAW,SAAA,GACA,SACA,CACA,GAAAX,EAAAU,KAAA,OAEA,OADAT,EAAAW,QAAA,CAAAC,IAAA,CAAAC,GACAA,EAAAd,EAAAC,EACA,CACA,GACAD,EAAAU,KAAA,CAAAb,GAAA,gBACA,GAAAG,EAAAU,KAAA,CAAAZ,GAAA,kBACA,GAAAE,EAAAU,KAAA,CAAAnB,IACAS,EAAAU,KAAA,CAAAlB,IACAQ,EAAAU,KAAA,CAAAjB,IACAO,EAAAU,KAAA,CAAAhB,GAHA,eAIA,GAAAM,EAAAU,KAAA,CAAAd,GAAA,iBACA,GAAAmB,iBAAAC,OAAA,CAAAR,GAAA,GAEA,OADAR,EAAAiB,IAAA,GACA,UACA,CACA,GAAAC,aAAAF,OAAA,CAAAR,GAAA,GAGA,OAFAR,EAAAiB,IAAA,GACAjB,EAAAU,KAAA,OACA,aACA,CAEA,GAAAH,EAAAP,EAAAU,KAAA,eACA,IAAAE,EAAAO,EAAAC,IAAA,MAAAb,CAAA,KAEA,OADAN,EAAAW,QAAA,CAAAC,IAAA,CAAAD,GACAA,EAAAZ,EAAAC,EACA,IAEAD,EAAAU,KAAA,CAAAf,GAAA,CACA,IAAA0B,EAAArB,EAAAsB,OAAA,UACA,EAAAC,cAAA,CAAAF,GAAA,OACAhC,EAAAkC,cAAA,CAAAF,GAAA,OACAlC,EAAAoC,cAAA,CAAAF,IACAjC,EAAAmC,cAAA,CAAAF,IACApB,CAAAA,EAAAC,IAAA,WACA,WAEAA,UAAAA,EAAA,MACA,UARA,CASA,OAEAF,EAAAiB,IAAA,GACA,KAsBA,SAAAE,EAAAK,CAAA,CAAAxB,CAAA,CAAAC,CAAA,EAGA,IAFA,IACAO,EADAiB,EAAAD,GAAAA,EAAAtC,MAAA,CACAwC,EAAA,GACAlB,EAAAR,EAAAS,IAAA,IACA,GAAAiB,EAAA,CAEA,GADA1B,EAAAiB,IAAA,GACAT,KAAAA,EAEA,OADAP,EAAAW,QAAA,CAAAC,IAAA,CAAAc,UA1BA,CACA,IAAAC,EAAA,EACA,gBAAA5B,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,IAAA2B,EAAA9B,EAAAC,EAAAC,EAAAC,GACA,GAAA2B,eAAAA,GACA,GAAA7B,KAAAA,EAAAsB,OAAA,KAAAM,OACA,GAAA5B,KAAAA,EAAAsB,OAAA,IACA,GAAAM,GAAAA,EAGA,OAFA5B,EAAA8B,MAAA,IACA7B,EAAAW,QAAA,CAAAmB,GAAA,GACA9B,EAAAW,QAAA,CAAAX,EAAAW,QAAA,CAAA1B,MAAA,IAAAc,EAAAC,EAEA,GAAA2B,CACA,EACA,OACAC,CACA,CACA,KAUA,QACA,CACAH,EAAA,EACA,MAAM,GAAA1B,EAAAU,KAAA,CAAAc,GAEN,OADAvB,EAAAW,QAAA,CAAAmB,GAAA,GACA,QAIA,CAFA/B,EAAAiB,IAAA,GACAS,EAAAlB,MAAAA,EACA,OAEAiB,GACAxB,EAAAW,QAAA,CAAAmB,GAAA,GAEA,QACA,CAEA,SAAAjB,EAAAd,CAAA,CAAAC,CAAA,EAEA,IADA,IAAAO,EACAA,EAAAR,EAAAiB,IAAA,IACA,GAAAT,MAAAA,GAAAR,EAAAgC,GAAA,MACA/B,EAAAW,QAAA,CAAAC,IAAA,CAAAC,QACM,GAAAN,MAAAA,GAAAR,EAAAgC,GAAA,OACN/B,EAAAW,QAAA,CAAAmB,GAAA,GACA,MACA,MAEA,SACA,CAEA,SAAAE,EAAA/B,CAAA,CAAAgC,CAAA,CAAA9B,CAAA,EACA,KAAAF,IAAA,CAAAA,EACA,KAAAgC,KAAA,CAAAA,EACA,KAAA9B,QAAA,CAAAA,CACA,CAEA,SAAA+B,EAAAlC,CAAA,CAAAD,CAAA,EACA,IAAAkC,EAAAlC,EAAAU,KAAA,2BAA+C,SAAAV,EAAAoC,MAAA,KAC/CnC,EAAAoC,OAAA,KAAAJ,EAAAhC,EAAAoC,OAAA,CAAAH,EAAAjC,EAAAG,QAAA,CACA,CAEA,SAAAkC,EAAArC,CAAA,EACAA,EAAAoC,OAAA,GACApC,EAAAG,QAAA,CAAAH,EAAAoC,OAAA,CAAAjC,QAAA,CACAH,EAAAoC,OAAA,CAAApC,EAAAoC,OAAA,CAAAnC,IAAA,CAEA,CAEO,IAAAqC,EAAA,CACPC,KAAA,QACAC,WAAA,WACA,OACAvC,KAAA,KACAmC,QAAA,KACAjC,SAAA,EACAQ,SAAA,GAEA,EAEA8B,MAAA,SAAA1C,CAAA,CAAAC,CAAA,EACA,IAAAC,EAAAD,EAAAC,IAAA,CACAD,EAAAC,IAAA,MAEA,IAAAyC,EAAA/B,CADAX,EAAAW,QAAA,CAAAX,EAAAW,QAAA,CAAA1B,MAAA,KAAAa,CAAA,EACAC,EAAAC,EAAAC,GAIA,GAHA,GAAAyC,WAAAA,EACA1C,EAAAC,IAAA,EAAAD,CAAAA,EAAAC,IAAA,CAAAyC,CAAA,EADA1C,EAAAC,IAAA,CAAAA,EAGAyC,eAAAA,EAAA,CACA,IAAAC,EAAA,sBAAsCC,IAAA,CAAA7C,EAAAsB,OAAA,IACtCsB,GAAA,CAAAA,CAAA,IAAAN,EAAAH,CAAA,EAAAlC,EAAAD,EACA,QAEA2C,CACA,EAEAG,OAAA,SAAA7C,CAAA,CAAA8C,CAAA,CAAAC,CAAA,EACA,IAAAC,EAAAhD,EAAAoC,OAAA,CACA,IAAAY,EAAA,SACA,IAAAC,EAAA,YAAyBC,IAAA,CAAAJ,UACzB,MAAAE,EAAAf,KAAA,CAAAe,EAAAf,KAAA,CAAAgB,CAAAA,EAAA,KACAD,EAAA7C,QAAA,CAAA8C,CAAAA,EAAA,EAAAF,EAAAI,IAAA,CADA,EAIAC,aAAA,CACAC,cAAA,gBACAC,cAAA,CAAoBC,KAAA,KAAAC,MAAA,CAAoBC,KAAA,KAAAC,MAAA,OACxCC,cAAA,CAAoBC,SAAA,aAAuB,aAC3C,CACA","sources":["webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/swift.js","webpack://_N_E/<anon>"],"sourcesContent":["function wordSet(words) {\n  var set = {}\n  for (var i = 0; i < words.length; i++) set[words[i]] = true\n  return set\n}\n\nvar keywords = wordSet([\"_\",\"var\",\"let\",\"actor\",\"class\",\"enum\",\"extension\",\"import\",\"protocol\",\"struct\",\"func\",\"typealias\",\"associatedtype\",\n                        \"open\",\"public\",\"internal\",\"fileprivate\",\"private\",\"deinit\",\"init\",\"new\",\"override\",\"self\",\"subscript\",\"super\",\n                        \"convenience\",\"dynamic\",\"final\",\"indirect\",\"lazy\",\"required\",\"static\",\"unowned\",\"unowned(safe)\",\"unowned(unsafe)\",\"weak\",\"as\",\"is\",\n                        \"break\",\"case\",\"continue\",\"default\",\"else\",\"fallthrough\",\"for\",\"guard\",\"if\",\"in\",\"repeat\",\"switch\",\"where\",\"while\",\n                        \"defer\",\"return\",\"inout\",\"mutating\",\"nonmutating\",\"isolated\",\"nonisolated\",\"catch\",\"do\",\"rethrows\",\"throw\",\"throws\",\"async\",\"await\",\"try\",\"didSet\",\"get\",\"set\",\"willSet\",\n                        \"assignment\",\"associativity\",\"infix\",\"left\",\"none\",\"operator\",\"postfix\",\"precedence\",\"precedencegroup\",\"prefix\",\"right\",\n                        \"Any\",\"AnyObject\",\"Type\",\"dynamicType\",\"Self\",\"Protocol\",\"__COLUMN__\",\"__FILE__\",\"__FUNCTION__\",\"__LINE__\"])\nvar definingKeywords = wordSet([\"var\",\"let\",\"actor\",\"class\",\"enum\",\"extension\",\"import\",\"protocol\",\"struct\",\"func\",\"typealias\",\"associatedtype\",\"for\"])\nvar atoms = wordSet([\"true\",\"false\",\"nil\",\"self\",\"super\",\"_\"])\nvar types = wordSet([\"Array\",\"Bool\",\"Character\",\"Dictionary\",\"Double\",\"Float\",\"Int\",\"Int8\",\"Int16\",\"Int32\",\"Int64\",\"Never\",\"Optional\",\"Set\",\"String\",\n                     \"UInt8\",\"UInt16\",\"UInt32\",\"UInt64\",\"Void\"])\nvar operators = \"+-/*%=|&<>~^?!\"\nvar punc = \":;,.(){}[]\"\nvar binary = /^\\-?0b[01][01_]*/\nvar octal = /^\\-?0o[0-7][0-7_]*/\nvar hexadecimal = /^\\-?0x[\\dA-Fa-f][\\dA-Fa-f_]*(?:(?:\\.[\\dA-Fa-f][\\dA-Fa-f_]*)?[Pp]\\-?\\d[\\d_]*)?/\nvar decimal = /^\\-?\\d[\\d_]*(?:\\.\\d[\\d_]*)?(?:[Ee]\\-?\\d[\\d_]*)?/\nvar identifier = /^\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1/\nvar property = /^\\.(?:\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1)/\nvar instruction = /^\\#[A-Za-z]+/\nvar attribute = /^@(?:\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1)/\n//var regexp = /^\\/(?!\\s)(?:\\/\\/)?(?:\\\\.|[^\\/])+\\//\n\nfunction tokenBase(stream, state, prev) {\n  if (stream.sol()) state.indented = stream.indentation()\n  if (stream.eatSpace()) return null\n\n  var ch = stream.peek()\n  if (ch == \"/\") {\n    if (stream.match(\"//\")) {\n      stream.skipToEnd()\n      return \"comment\"\n    }\n    if (stream.match(\"/*\")) {\n      state.tokenize.push(tokenComment)\n      return tokenComment(stream, state)\n    }\n  }\n  if (stream.match(instruction)) return \"builtin\"\n  if (stream.match(attribute)) return \"attribute\"\n  if (stream.match(binary)) return \"number\"\n  if (stream.match(octal)) return \"number\"\n  if (stream.match(hexadecimal)) return \"number\"\n  if (stream.match(decimal)) return \"number\"\n  if (stream.match(property)) return \"property\"\n  if (operators.indexOf(ch) > -1) {\n    stream.next()\n    return \"operator\"\n  }\n  if (punc.indexOf(ch) > -1) {\n    stream.next()\n    stream.match(\"..\")\n    return \"punctuation\"\n  }\n  var stringMatch\n  if (stringMatch = stream.match(/(\"\"\"|\"|')/)) {\n    var tokenize = tokenString.bind(null, stringMatch[0])\n    state.tokenize.push(tokenize)\n    return tokenize(stream, state)\n  }\n\n  if (stream.match(identifier)) {\n    var ident = stream.current()\n    if (types.hasOwnProperty(ident)) return \"type\"\n    if (atoms.hasOwnProperty(ident)) return \"atom\"\n    if (keywords.hasOwnProperty(ident)) {\n      if (definingKeywords.hasOwnProperty(ident))\n        state.prev = \"define\"\n      return \"keyword\"\n    }\n    if (prev == \"define\") return \"def\"\n    return \"variable\"\n  }\n\n  stream.next()\n  return null\n}\n\nfunction tokenUntilClosingParen() {\n  var depth = 0\n  return function(stream, state, prev) {\n    var inner = tokenBase(stream, state, prev)\n    if (inner == \"punctuation\") {\n      if (stream.current() == \"(\") ++depth\n      else if (stream.current() == \")\") {\n        if (depth == 0) {\n          stream.backUp(1)\n          state.tokenize.pop()\n          return state.tokenize[state.tokenize.length - 1](stream, state)\n        }\n        else --depth\n      }\n    }\n    return inner\n  }\n}\n\nfunction tokenString(openQuote, stream, state) {\n  var singleLine = openQuote.length == 1\n  var ch, escaped = false\n  while (ch = stream.peek()) {\n    if (escaped) {\n      stream.next()\n      if (ch == \"(\") {\n        state.tokenize.push(tokenUntilClosingParen())\n        return \"string\"\n      }\n      escaped = false\n    } else if (stream.match(openQuote)) {\n      state.tokenize.pop()\n      return \"string\"\n    } else {\n      stream.next()\n      escaped = ch == \"\\\\\"\n    }\n  }\n  if (singleLine) {\n    state.tokenize.pop()\n  }\n  return \"string\"\n}\n\nfunction tokenComment(stream, state) {\n  var ch\n  while (ch = stream.next()) {\n    if (ch === \"/\" && stream.eat(\"*\")) {\n      state.tokenize.push(tokenComment)\n    } else if (ch === \"*\" && stream.eat(\"/\")) {\n      state.tokenize.pop()\n      break\n    }\n  }\n  return \"comment\"\n}\n\nfunction Context(prev, align, indented) {\n  this.prev = prev\n  this.align = align\n  this.indented = indented\n}\n\nfunction pushContext(state, stream) {\n  var align = stream.match(/^\\s*($|\\/[\\/\\*]|[)}\\]])/, false) ? null : stream.column() + 1\n  state.context = new Context(state.context, align, state.indented)\n}\n\nfunction popContext(state) {\n  if (state.context) {\n    state.indented = state.context.indented\n    state.context = state.context.prev\n  }\n}\n\nexport const swift = {\n  name: \"swift\",\n  startState: function() {\n    return {\n      prev: null,\n      context: null,\n      indented: 0,\n      tokenize: []\n    }\n  },\n\n  token: function(stream, state) {\n    var prev = state.prev\n    state.prev = null\n    var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase\n    var style = tokenize(stream, state, prev)\n    if (!style || style == \"comment\") state.prev = prev\n    else if (!state.prev) state.prev = style\n\n    if (style == \"punctuation\") {\n      var bracket = /[\\(\\[\\{]|([\\]\\)\\}])/.exec(stream.current())\n      if (bracket) (bracket[1] ? popContext : pushContext)(state, stream)\n    }\n\n    return style\n  },\n\n  indent: function(state, textAfter, iCx) {\n    var cx = state.context\n    if (!cx) return 0\n    var closing = /^[\\]\\}\\)]/.test(textAfter)\n    if (cx.align != null) return cx.align - (closing ? 1 : 0)\n    return cx.indented + (closing ? 0 : iCx.unit)\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[\\)\\}\\]]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}},\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"]}\n  }\n}\n"],"names":["wordSet","words","set","i","length","keywords","definingKeywords","atoms","types","binary","octal","hexadecimal","decimal","identifier","property","instruction","attribute","tokenBase","stream","state","prev","sol","indented","indentation","eatSpace","stringMatch","ch","peek","match","skipToEnd","tokenize","push","tokenComment","operators","indexOf","next","punc","tokenString","bind","ident","current","hasOwnProperty","openQuote","singleLine","escaped","tokenUntilClosingParen","depth","inner","backUp","pop","eat","Context","align","pushContext","column","context","popContext","swift","name","startState","token","style","bracket","exec","indent","textAfter","iCx","cx","closing","test","unit","languageData","indentOnInput","commentTokens","line","block","open","close","closeBrackets","brackets"],"sourceRoot":""}