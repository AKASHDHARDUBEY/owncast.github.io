{"version":3,"file":"static/chunks/8029.c0eb569e304cdaef.js","mappings":"mGAAA,SAAAA,EAAAC,CAAA,EACA,IAAAC,EAAAD,EAAAE,KAAA,WAEA,OADAF,EAAAG,SAAA,GACAF,EAAA,6DAGO,IAAAG,EAAA,CACPC,KAAA,aACAC,MAAA,SAAAN,CAAA,CAAAO,CAAA,EACA,IAAAC,EACA,GAAAD,OAAAA,EAAAA,KAAA,QACA,EAAAE,GAAA,IAAAD,CAAAA,EAAAR,EAAAE,KAAA,iCACAK,EAAAA,KAAA,WACAA,EAAAG,IAAA,CAAAF,CAAA,IACA,OAEAT,EAAAC,EADA,CAEM,GAAAO,WAAAA,EAAAA,KAAA,EACN,GAAAP,EAAAS,GAAA,IAAAT,EAAAE,KAAA,UAEA,OADAK,EAAAA,KAAA,UACA,MAKA,CAHA,IAAAI,EAAAZ,EAAAC,GAEA,OADAW,GAAAJ,CAAAA,EAAAA,KAAA,SACAI,CAEA,CAmBA,MAnBM,UAAAJ,EAAAA,KAAA,EACNP,EAAAG,SAAA,GACAI,EAAAA,KAAA,WACA,UACMA,QAAAA,EAAAA,KAAA,CACN,EAAAE,GAAA,IAAAD,CAAAA,EAAAR,EAAAE,KAAA,8BACA,MAAAK,EAAAG,IAAA,UACAH,EAAAA,KAAA,OACA,MAFA,CAIA,EAAAK,QAAA,oBACA,MAEAZ,EAAAa,IAAA,GACA,QACA,CAEMN,OAAAA,EAAAA,KAAA,CACNR,EAAAC,SACA,EAEAc,UAAA,SAAAP,CAAA,EACA,WAAAA,EAAAA,KAAA,EAAAA,CAAAA,EAAAA,KAAA,QACA,EACAQ,WAAA,WACA,OAAYR,MAAA,MAAAG,KAAA,KACZ,CACA","sources":["webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/asciiarmor.js","webpack://_N_E/<anon>"],"sourcesContent":["function errorIfNotEmpty(stream) {\n  var nonWS = stream.match(/^\\s*\\S/);\n  stream.skipToEnd();\n  return nonWS ? \"error\" : null;\n}\n\nexport const asciiArmor = {\n  name: \"asciiarmor\",\n  token: function(stream, state) {\n    var m;\n    if (state.state == \"top\") {\n      if (stream.sol() && (m = stream.match(/^-----BEGIN (.*)?-----\\s*$/))) {\n        state.state = \"headers\";\n        state.type = m[1];\n        return \"tag\";\n      }\n      return errorIfNotEmpty(stream);\n    } else if (state.state == \"headers\") {\n      if (stream.sol() && stream.match(/^\\w+:/)) {\n        state.state = \"header\";\n        return \"atom\";\n      } else {\n        var result = errorIfNotEmpty(stream);\n        if (result) state.state = \"body\";\n        return result;\n      }\n    } else if (state.state == \"header\") {\n      stream.skipToEnd();\n      state.state = \"headers\";\n      return \"string\";\n    } else if (state.state == \"body\") {\n      if (stream.sol() && (m = stream.match(/^-----END (.*)?-----\\s*$/))) {\n        if (m[1] != state.type) return \"error\";\n        state.state = \"end\";\n        return \"tag\";\n      } else {\n        if (stream.eatWhile(/[A-Za-z0-9+\\/=]/)) {\n          return null;\n        } else {\n          stream.next();\n          return \"error\";\n        }\n      }\n    } else if (state.state == \"end\") {\n      return errorIfNotEmpty(stream);\n    }\n  },\n  blankLine: function(state) {\n    if (state.state == \"headers\") state.state = \"body\";\n  },\n  startState: function() {\n    return {state: \"top\", type: null};\n  }\n};\n"],"names":["errorIfNotEmpty","stream","nonWS","match","skipToEnd","asciiArmor","name","token","state","m","sol","type","result","eatWhile","next","blankLine","startState"],"sourceRoot":""}