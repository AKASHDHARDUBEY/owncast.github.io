{"version":3,"file":"static/chunks/4163.56738f5d533d0932.js","mappings":"+IAKA,IAAAA,EAAAC,SALAC,CAAA,EAEA,QADAC,EAAA,GAAcF,EAAAC,EAAAE,KAAA,MACdC,EAAA,EAAkBA,EAAAJ,EAAAK,MAAA,CAAkB,EAAAD,EAAAF,CAAA,CAAAF,CAAA,CAAAI,EAAA,KACpC,OAAAF,CACA,EAEA,w9BAcAI,EAAA,CAAa,SAEbC,EAAA,mBAEA,SAAAC,EAAAC,CAAA,CAAAC,CAAA,EACA,IAAAC,EAAAF,EAAAG,IAAA,GACA,GAAAD,KAAAA,GAAAD,EAAAG,WAAA,CAEA,OADAJ,EAAAK,SAAA,GACA,MACA,CACA,GAAAH,KAAAA,GAAAA,KAAAA,EAEA,OADAD,EAAAK,QAAA,CAoCA,SAAAN,CAAA,CAAAC,CAAA,EAEA,IADA,IAAAE,EAAAI,EAAA,GAAAC,EAAA,GACA,MAAAL,CAAAA,EAAAH,EAAAG,IAAA,MACA,GAAAA,GAvCAD,GAuCA,CAAAK,EAAA,CAAsCC,EAAA,GAAY,QAClD,CAAAD,GAAAJ,MAAAA,CACA,CAEA,MADAK,CAAAA,GAAA,CAAAD,CAAA,GAAAN,CAAAA,EAAAK,QAAA,OACA,QACA,EA3CAL,EAAAK,QAAA,CAAAN,EAAAC,EACA,CACA,GAAAC,KAAAA,GAAAF,EAAAS,GAAA,MAEA,OADAR,EAAAK,QAAA,CAAAI,EACAA,EAAAV,EAAAC,EACA,CACA,GAAAC,KAAAA,EAEA,OADAD,EAAAK,QAAA,CAAAK,EACAA,EAAAX,EAAAC,EACA,CACA,sBAAkBW,IAAA,CAAAV,GAClB,YAEA,QAAAU,IAAA,CAAAV,GAEA,OADAF,EAAAa,QAAA,WACA,QACA,CACA,GAAAX,KAAAA,GACAF,EAAAS,GAAA,MAEA,OADAT,EAAAK,SAAA,GACA,SAEA,CACA,GAAAP,EAAAc,IAAA,CAAAV,GAEA,OADAF,EAAAa,QAAA,CAAAf,GACA,UACA,CACAE,EAAAa,QAAA,YACA,IAAAC,EAAAd,EAAAe,OAAA,UACA,EAAAC,oBAAA,CAAAF,GAAA,UACAjB,EAAAmB,oBAAA,CAAAF,GAAA,OACA,UAFA,CAiBA,SAAAJ,EAAAV,CAAA,CAAAC,CAAA,EAEA,IADA,IAAAC,EAAAe,EAAA,GACAf,EAAAF,EAAAG,IAAA,KACA,GAAAD,KAAAA,GAAAe,EAAA,CACAhB,EAAAK,QAAA,MACA,MACA,EACAJ,KAAAA,CACA,CACA,eACA,CAEA,SAAAS,EAAAX,CAAA,CAAAC,CAAA,EAEA,IADA,IAAAC,EACAA,EAAAF,EAAAG,IAAA,IACA,GAAAD,KAAAA,EAAgB,CAChBD,EAAAK,QAAA,MACA,MACA,MAEA,SACA,CAIO,IAAAY,EAAA,CACPC,KAAA,SAEAC,WAAA,WACA,OAAYd,SAAA,KACZ,EAEAe,MAAA,SAAArB,CAAA,CAAAC,CAAA,SACA,EAAAqB,QAAA,QACA,CAAArB,EAAAK,QAAA,EAAAP,CAAA,EAAAC,EAAAC,EADA,EAMAsB,aAAA,CACAC,cAAA,YACAC,cAAA,CAAoBC,MAAA,CAAQC,KAAA,KAAAC,MAAA,MAC5B,CACA","sources":["webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/pascal.js","webpack://_N_E/<anon>"],"sourcesContent":["function words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nvar keywords = words(\n  \"absolute and array asm begin case const constructor destructor div do \" +\n    \"downto else end file for function goto if implementation in inherited \" +\n    \"inline interface label mod nil not object of operator or packed procedure \" +\n    \"program record reintroduce repeat self set shl shr string then to type \" +\n    \"unit until uses var while with xor as class dispinterface except exports \" +\n    \"finalization finally initialization inline is library on out packed \" +\n    \"property raise resourcestring threadvar try absolute abstract alias \" +\n    \"assembler bitpacked break cdecl continue cppdecl cvar default deprecated \" +\n    \"dynamic enumerator experimental export external far far16 forward generic \" +\n    \"helper implements index interrupt iocheck local message name near \" +\n    \"nodefault noreturn nostackframe oldfpccall otherwise overload override \" +\n    \"pascal platform private protected public published read register \" +\n    \"reintroduce result safecall saveregisters softfloat specialize static \" +\n    \"stdcall stored strict unaligned unimplemented varargs virtual write\");\nvar atoms = {\"null\": true};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == \"#\" && state.startOfLine) {\n    stream.skipToEnd();\n    return \"meta\";\n  }\n  if (ch == '\"' || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n  if (ch == \"(\" && stream.eat(\"*\")) {\n    state.tokenize = tokenComment;\n    return tokenComment(stream, state);\n  }\n  if (ch == \"{\") {\n    state.tokenize = tokenCommentBraces;\n    return tokenCommentBraces(stream, state);\n  }\n  if (/[\\[\\]\\(\\),;\\:\\.]/.test(ch)) {\n    return null;\n  }\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  }\n  if (ch == \"/\") {\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n  stream.eatWhile(/[\\w\\$_]/);\n  var cur = stream.current();\n  if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  return \"variable\";\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {end = true; break;}\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !escaped) state.tokenize = null;\n    return \"string\";\n  };\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \")\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenCommentBraces(stream, state) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"}\") {\n      state.tokenize = null;\n      break;\n    }\n  }\n  return \"comment\";\n}\n\n// Interface\n\nexport const pascal = {\n  name: \"pascal\",\n\n  startState: function() {\n    return {tokenize: null};\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\" || style == \"meta\") return style;\n    return style;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {block: {open: \"(*\", close: \"*)\"}}\n  }\n};\n"],"names":["keywords","words","str","obj","split","i","length","atoms","isOperatorChar","tokenBase","stream","state","ch","next","startOfLine","skipToEnd","tokenize","escaped","end","eat","tokenComment","tokenCommentBraces","test","eatWhile","cur","current","propertyIsEnumerable","maybeEnd","pascal","name","startState","token","eatSpace","languageData","indentOnInput","commentTokens","block","open","close"],"sourceRoot":""}