{"version":3,"file":"static/chunks/5372.c761c026a7f37bb5.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/haskell.js","webpack://_N_E/<anon>"],"sourcesContent":["function switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n}\n\n// These should all be Unicode extended, as per the Haskell 2010 report\nvar smallRE = /[a-z_]/;\nvar largeRE = /[A-Z]/;\nvar digitRE = /\\d/;\nvar hexitRE = /[0-9A-Fa-f]/;\nvar octitRE = /[0-7]/;\nvar idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\nvar symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar specialRE = /[(),;[\\]`{}]/;\nvar whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal(source, setState) {\n  if (source.eatWhile(whiteCharRE)) {\n    return null;\n  }\n\n  var ch = source.next();\n  if (specialRE.test(ch)) {\n    if (ch == '{' && source.eat('-')) {\n      var t = \"comment\";\n      if (source.eat('#')) {\n        t = \"meta\";\n      }\n      return switchState(source, setState, ncomment(t, 1));\n    }\n    return null;\n  }\n\n  if (ch == '\\'') {\n    if (source.eat('\\\\')) {\n      source.next();  // should handle other escapes here\n    }\n    else {\n      source.next();\n    }\n    if (source.eat('\\'')) {\n      return \"string\";\n    }\n    return \"error\";\n  }\n\n  if (ch == '\"') {\n    return switchState(source, setState, stringLiteral);\n  }\n\n  if (largeRE.test(ch)) {\n    source.eatWhile(idRE);\n    if (source.eat('.')) {\n      return \"qualifier\";\n    }\n    return \"type\";\n  }\n\n  if (smallRE.test(ch)) {\n    source.eatWhile(idRE);\n    return \"variable\";\n  }\n\n  if (digitRE.test(ch)) {\n    if (ch == '0') {\n      if (source.eat(/[xX]/)) {\n        source.eatWhile(hexitRE); // should require at least 1\n        return \"integer\";\n      }\n      if (source.eat(/[oO]/)) {\n        source.eatWhile(octitRE); // should require at least 1\n        return \"number\";\n      }\n    }\n    source.eatWhile(digitRE);\n    var t = \"number\";\n    if (source.match(/^\\.\\d+/)) {\n      t = \"number\";\n    }\n    if (source.eat(/[eE]/)) {\n      t = \"number\";\n      source.eat(/[-+]/);\n      source.eatWhile(digitRE); // should require at least 1\n    }\n    return t;\n  }\n\n  if (ch == \".\" && source.eat(\".\"))\n    return \"keyword\";\n\n  if (symbolRE.test(ch)) {\n    if (ch == '-' && source.eat(/-/)) {\n      source.eatWhile(/-/);\n      if (!source.eat(symbolRE)) {\n        source.skipToEnd();\n        return \"comment\";\n      }\n    }\n    source.eatWhile(symbolRE);\n    return \"variable\"\n  }\n\n  return \"error\";\n}\n\nfunction ncomment(type, nest) {\n  if (nest == 0) {\n    return normal;\n  }\n  return function(source, setState) {\n    var currNest = nest;\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '{' && source.eat('-')) {\n        ++currNest;\n      }\n      else if (ch == '-' && source.eat('}')) {\n        --currNest;\n        if (currNest == 0) {\n          setState(normal);\n          return type;\n        }\n      }\n    }\n    setState(ncomment(type, currNest));\n    return type;\n  };\n}\n\nfunction stringLiteral(source, setState) {\n  while (!source.eol()) {\n    var ch = source.next();\n    if (ch == '\"') {\n      setState(normal);\n      return \"string\";\n    }\n    if (ch == '\\\\') {\n      if (source.eol() || source.eat(whiteCharRE)) {\n        setState(stringGap);\n        return \"string\";\n      }\n      if (source.eat('&')) {\n      }\n      else {\n        source.next(); // should handle other escapes here\n      }\n    }\n  }\n  setState(normal);\n  return \"error\";\n}\n\nfunction stringGap(source, setState) {\n  if (source.eat('\\\\')) {\n    return switchState(source, setState, stringLiteral);\n  }\n  source.next();\n  setState(normal);\n  return \"error\";\n}\n\n\nvar wellKnownWords = (function() {\n  var wkw = {};\n  function setType(t) {\n    return function () {\n      for (var i = 0; i < arguments.length; i++)\n        wkw[arguments[i]] = t;\n    };\n  }\n\n  setType(\"keyword\")(\n    \"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\",\n    \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\",\n    \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n\n  setType(\"keyword\")(\n    \"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n\n  setType(\"builtin\")(\n    \"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\",\n    \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\",\n    \"*>\", \"**\");\n\n  setType(\"builtin\")(\n    \"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\",\n    \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\",\n    \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\",\n    \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\",\n    \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\",\n    \"String\", \"True\");\n\n  setType(\"builtin\")(\n    \"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\",\n    \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\",\n    \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\",\n    \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\",\n    \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\",\n    \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\",\n    \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\",\n    \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\",\n    \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\",\n    \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\",\n    \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\",\n    \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\",\n    \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\",\n    \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\",\n    \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\",\n    \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\",\n    \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\",\n    \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\",\n    \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\",\n    \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\",\n    \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\",\n    \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\",\n    \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\",\n    \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\",\n    \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\",\n    \"zip3\", \"zipWith\", \"zipWith3\");\n\n  return wkw;\n})();\n\nexport const haskell = {\n  name: \"haskell\",\n  startState: function ()  { return { f: normal }; },\n  copyState:  function (s) { return { f: s.f }; },\n\n  token: function(stream, state) {\n    var t = state.f(stream, function(s) { state.f = s; });\n    var w = stream.current();\n    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n  },\n\n  languageData: {\n    commentTokens: {line: \"--\", block: {open: \"{-\", close: \"-}\"}}\n  }\n};\n"],"names":["smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","normal","source","setState","eatWhile","f","ch","next","test","eat","t","ncomment","type","nest","currNest","eol","stringLiteral","match","skipToEnd","stringGap","wellKnownWords","wkw","setType","i","arguments","length","haskell","name","startState","copyState","s","token","stream","state","w","current","hasOwnProperty","languageData","commentTokens","line","block","open","close"],"sourceRoot":""}