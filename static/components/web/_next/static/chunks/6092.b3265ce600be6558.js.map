{"version":3,"file":"static/chunks/6092.b3265ce600be6558.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/julia.js","webpack://_N_E/<anon>"],"sourcesContent":["function wordRegexp(words, end, pre) {\n  if (typeof pre === \"undefined\") pre = \"\";\n  if (typeof end === \"undefined\") { end = \"\\\\b\"; }\n  return new RegExp(\"^\" + pre + \"((\" + words.join(\")|(\") + \"))\" + end);\n}\n\nvar octChar = \"\\\\\\\\[0-7]{1,3}\";\nvar hexChar = \"\\\\\\\\x[A-Fa-f0-9]{1,2}\";\nvar sChar = \"\\\\\\\\[abefnrtv0%?'\\\"\\\\\\\\]\";\nvar uChar = \"([^\\\\u0027\\\\u005C\\\\uD800-\\\\uDFFF]|[\\\\uD800-\\\\uDFFF][\\\\uDC00-\\\\uDFFF])\";\n\nvar asciiOperatorsList = [\n  \"[<>]:\", \"[<>=]=\", \"<<=?\", \">>>?=?\", \"=>\", \"--?>\", \"<--[->]?\", \"\\\\/\\\\/\",\n  \"\\\\.{2,3}\", \"[\\\\.\\\\\\\\%*+\\\\-<>!\\\\/^|&]=?\", \"\\\\?\", \"\\\\$\", \"~\", \":\"\n];\nvar operators = wordRegexp([\n  \"[<>]:\", \"[<>=]=\", \"[!=]==\", \"<<=?\", \">>>?=?\", \"=>?\", \"--?>\", \"<--[->]?\", \"\\\\/\\\\/\",\n  \"[\\\\\\\\%*+\\\\-<>!\\\\/^|&\\\\u00F7\\\\u22BB]=?\", \"\\\\?\", \"\\\\$\", \"~\", \":\",\n  \"\\\\u00D7\", \"\\\\u2208\", \"\\\\u2209\", \"\\\\u220B\", \"\\\\u220C\", \"\\\\u2218\",\n  \"\\\\u221A\", \"\\\\u221B\", \"\\\\u2229\", \"\\\\u222A\", \"\\\\u2260\", \"\\\\u2264\",\n  \"\\\\u2265\", \"\\\\u2286\", \"\\\\u2288\", \"\\\\u228A\", \"\\\\u22C5\",\n  \"\\\\b(in|isa)\\\\b(?!\\.?\\\\()\"\n], \"\");\nvar delimiters = /^[;,()[\\]{}]/;\nvar identifiers = /^[_A-Za-z\\u00A1-\\u2217\\u2219-\\uFFFF][\\w\\u00A1-\\u2217\\u2219-\\uFFFF]*!*/;\n\nvar chars = wordRegexp([octChar, hexChar, sChar, uChar], \"'\");\n\nvar openersList = [\"begin\", \"function\", \"type\", \"struct\", \"immutable\", \"let\",\n                   \"macro\", \"for\", \"while\", \"quote\", \"if\", \"else\", \"elseif\", \"try\",\n                   \"finally\", \"catch\", \"do\"];\n\nvar closersList = [\"end\", \"else\", \"elseif\", \"catch\", \"finally\"];\n\nvar keywordsList = [\"if\", \"else\", \"elseif\", \"while\", \"for\", \"begin\", \"let\",\n                    \"end\", \"do\", \"try\", \"catch\", \"finally\", \"return\", \"break\", \"continue\",\n                    \"global\", \"local\", \"const\", \"export\", \"import\", \"importall\", \"using\",\n                    \"function\", \"where\", \"macro\", \"module\", \"baremodule\", \"struct\", \"type\",\n                    \"mutable\", \"immutable\", \"quote\", \"typealias\", \"abstract\", \"primitive\",\n                    \"bitstype\"];\n\nvar builtinsList = [\"true\", \"false\", \"nothing\", \"NaN\", \"Inf\"];\n\nvar openers = wordRegexp(openersList);\nvar closers = wordRegexp(closersList);\nvar keywords = wordRegexp(keywordsList);\nvar builtins = wordRegexp(builtinsList);\n\nvar macro = /^@[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\nvar symbol = /^:[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\nvar stringPrefixes = /^(`|([_A-Za-z\\u00A1-\\uFFFF]*\"(\"\")?))/;\n\nvar macroOperators = wordRegexp(asciiOperatorsList, \"\", \"@\");\nvar symbolOperators = wordRegexp(asciiOperatorsList, \"\", \":\");\n\nfunction inArray(state) {\n  return (state.nestedArrays > 0);\n}\n\nfunction inGenerator(state) {\n  return (state.nestedGenerators > 0);\n}\n\nfunction currentScope(state, n) {\n  if (typeof(n) === \"undefined\") { n = 0; }\n  if (state.scopes.length <= n) {\n    return null;\n  }\n  return state.scopes[state.scopes.length - (n + 1)];\n}\n\n// tokenizers\nfunction tokenBase(stream, state) {\n  // Handle multiline comments\n  if (stream.match('#=', false)) {\n    state.tokenize = tokenComment;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle scope changes\n  var leavingExpr = state.leavingExpr;\n  if (stream.sol()) {\n    leavingExpr = false;\n  }\n  state.leavingExpr = false;\n\n  if (leavingExpr) {\n    if (stream.match(/^'+/)) {\n      return \"operator\";\n    }\n  }\n\n  if (stream.match(/\\.{4,}/)) {\n    return \"error\";\n  } else if (stream.match(/\\.{1,3}/)) {\n    return \"operator\";\n  }\n\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var ch = stream.peek();\n\n  // Handle single line comments\n  if (ch === '#') {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  if (ch === '[') {\n    state.scopes.push('[');\n    state.nestedArrays++;\n  }\n\n  if (ch === '(') {\n    state.scopes.push('(');\n    state.nestedGenerators++;\n  }\n\n  if (inArray(state) && ch === ']') {\n    while (state.scopes.length && currentScope(state) !== \"[\") { state.scopes.pop(); }\n    state.scopes.pop();\n    state.nestedArrays--;\n    state.leavingExpr = true;\n  }\n\n  if (inGenerator(state) && ch === ')') {\n    while (state.scopes.length && currentScope(state) !== \"(\") { state.scopes.pop(); }\n    state.scopes.pop();\n    state.nestedGenerators--;\n    state.leavingExpr = true;\n  }\n\n  if (inArray(state)) {\n    if (state.lastToken == \"end\" && stream.match(':')) {\n      return \"operator\";\n    }\n    if (stream.match('end')) {\n      return \"number\";\n    }\n  }\n\n  var match;\n  if (match = stream.match(openers, false)) {\n    state.scopes.push(match[0]);\n  }\n\n  if (stream.match(closers, false)) {\n    state.scopes.pop();\n  }\n\n  // Handle type annotations\n  if (stream.match(/^::(?![:\\$])/)) {\n    state.tokenize = tokenAnnotation;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle symbols\n  if (!leavingExpr && (stream.match(symbol) || stream.match(symbolOperators))) {\n    return \"builtin\";\n  }\n\n  // Handle parametric types\n  //if (stream.match(/^{[^}]*}(?=\\()/)) {\n  //  return \"builtin\";\n  //}\n\n  // Handle operators and Delimiters\n  if (stream.match(operators)) {\n    return \"operator\";\n  }\n\n  // Handle Number Literals\n  if (stream.match(/^\\.?\\d/, false)) {\n    var imMatcher = RegExp(/^im\\b/);\n    var numberLiteral = false;\n    if (stream.match(/^0x\\.[0-9a-f_]+p[\\+\\-]?[_\\d]+/i)) { numberLiteral = true; }\n    // Integers\n    if (stream.match(/^0x[0-9a-f_]+/i)) { numberLiteral = true; } // Hex\n    if (stream.match(/^0b[01_]+/i)) { numberLiteral = true; } // Binary\n    if (stream.match(/^0o[0-7_]+/i)) { numberLiteral = true; } // Octal\n    // Floats\n    if (stream.match(/^(?:(?:\\d[_\\d]*)?\\.(?!\\.)(?:\\d[_\\d]*)?|\\d[_\\d]*\\.(?!\\.)(?:\\d[_\\d]*))?([Eef][\\+\\-]?[_\\d]+)?/i)) { numberLiteral = true; }\n    if (stream.match(/^\\d[_\\d]*(e[\\+\\-]?\\d+)?/i)) { numberLiteral = true; } // Decimal\n    if (numberLiteral) {\n      // Integer literals may be \"long\"\n      stream.match(imMatcher);\n      state.leavingExpr = true;\n      return \"number\";\n    }\n  }\n\n  // Handle Chars\n  if (stream.match(\"'\")) {\n    state.tokenize = tokenChar;\n    return state.tokenize(stream, state);\n  }\n\n  // Handle Strings\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenStringFactory(stream.current());\n    return state.tokenize(stream, state);\n  }\n\n  if (stream.match(macro) || stream.match(macroOperators)) {\n    return \"meta\";\n  }\n\n  if (stream.match(delimiters)) {\n    return null;\n  }\n\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n\n  if (stream.match(builtins)) {\n    return \"builtin\";\n  }\n\n  var isDefinition = state.isDefinition || state.lastToken == \"function\" ||\n      state.lastToken == \"macro\" || state.lastToken == \"type\" ||\n      state.lastToken == \"struct\" || state.lastToken == \"immutable\";\n\n  if (stream.match(identifiers)) {\n    if (isDefinition) {\n      if (stream.peek() === '.') {\n        state.isDefinition = true;\n        return \"variable\";\n      }\n      state.isDefinition = false;\n      return \"def\";\n    }\n    state.leavingExpr = true;\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return \"error\";\n}\n\nfunction tokenAnnotation(stream, state) {\n  stream.match(/.*?(?=[,;{}()=\\s]|$)/);\n  if (stream.match('{')) {\n    state.nestedParameters++;\n  } else if (stream.match('}') && state.nestedParameters > 0) {\n    state.nestedParameters--;\n  }\n  if (state.nestedParameters > 0) {\n    stream.match(/.*?(?={|})/) || stream.next();\n  } else if (state.nestedParameters == 0) {\n    state.tokenize = tokenBase;\n  }\n  return \"builtin\";\n}\n\nfunction tokenComment(stream, state) {\n  if (stream.match('#=')) {\n    state.nestedComments++;\n  }\n  if (!stream.match(/.*?(?=(#=|=#))/)) {\n    stream.skipToEnd();\n  }\n  if (stream.match('=#')) {\n    state.nestedComments--;\n    if (state.nestedComments == 0)\n      state.tokenize = tokenBase;\n  }\n  return \"comment\";\n}\n\nfunction tokenChar(stream, state) {\n  var isChar = false, match;\n  if (stream.match(chars)) {\n    isChar = true;\n  } else if (match = stream.match(/\\\\u([a-f0-9]{1,4})(?=')/i)) {\n    var value = parseInt(match[1], 16);\n    if (value <= 55295 || value >= 57344) { // (U+0,U+D7FF), (U+E000,U+FFFF)\n      isChar = true;\n      stream.next();\n    }\n  } else if (match = stream.match(/\\\\U([A-Fa-f0-9]{5,8})(?=')/)) {\n    var value = parseInt(match[1], 16);\n    if (value <= 1114111) { // U+10FFFF\n      isChar = true;\n      stream.next();\n    }\n  }\n  if (isChar) {\n    state.leavingExpr = true;\n    state.tokenize = tokenBase;\n    return \"string\";\n  }\n  if (!stream.match(/^[^']+(?=')/)) { stream.skipToEnd(); }\n  if (stream.match(\"'\")) { state.tokenize = tokenBase; }\n  return \"error\";\n}\n\nfunction tokenStringFactory(delimiter) {\n  if (delimiter.substr(-3) === '\"\"\"') {\n    delimiter = '\"\"\"';\n  } else if (delimiter.substr(-1) === '\"') {\n    delimiter = '\"';\n  }\n  function tokenString(stream, state) {\n    if (stream.eat('\\\\')) {\n      stream.next();\n    } else if (stream.match(delimiter)) {\n      state.tokenize = tokenBase;\n      state.leavingExpr = true;\n      return \"string\";\n    } else {\n      stream.eat(/[`\"]/);\n    }\n    stream.eatWhile(/[^\\\\`\"]/);\n    return \"string\";\n  }\n  return tokenString;\n}\n\nexport const julia = {\n  name: \"julia\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      scopes: [],\n      lastToken: null,\n      leavingExpr: false,\n      isDefinition: false,\n      nestedArrays: 0,\n      nestedComments: 0,\n      nestedGenerators: 0,\n      nestedParameters: 0,\n      firstParenPos: -1\n    };\n  },\n\n  token: function(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    if (current && style) {\n      state.lastToken = current;\n    }\n\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    var delta = 0;\n    if ( textAfter === ']' || textAfter === ')' || /^end\\b/.test(textAfter) ||\n         /^else/.test(textAfter) || /^catch\\b/.test(textAfter) || /^elseif\\b/.test(textAfter) ||\n         /^finally/.test(textAfter) ) {\n      delta = -1;\n    }\n    return (state.scopes.length + delta) * cx.unit;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*(end|else|catch|finally)\\b$/,\n    commentTokens: {line: \"#\", block: {open: \"#=\", close: \"=#\"}},\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", '\"']},\n    autocomplete: keywordsList.concat(builtinsList)\n  }\n};\n"],"names":["wordRegexp","words","end","pre","join","asciiOperatorsList","operators","delimiters","identifiers","chars","keywordsList","builtinsList","openers","closers","keywords","builtins","macro","symbol","stringPrefixes","macroOperators","symbolOperators","inArray","state","nestedArrays","currentScope","n","scopes","length","tokenBase","stream","match","tokenize","tokenComment","delimiter","leavingExpr","sol","eatSpace","ch","peek","skipToEnd","push","nestedGenerators","pop","inGenerator","lastToken","tokenAnnotation","imMatcher","RegExp","numberLiteral","tokenChar","current","substr","eat","next","eatWhile","isDefinition","nestedParameters","nestedComments","isChar","value","parseInt","julia","name","startState","firstParenPos","token","style","indent","textAfter","cx","delta","test","unit","languageData","indentOnInput","commentTokens","line","block","open","close","closeBrackets","brackets","autocomplete","concat"],"sourceRoot":""}