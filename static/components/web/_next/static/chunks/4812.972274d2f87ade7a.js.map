{"version":3,"file":"static/chunks/4812.972274d2f87ade7a.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/dockerfile.js","webpack://_N_E/./node_modules/@codemirror/legacy-modes/mode/simple-mode.js","webpack://_N_E/<anon>"],"sourcesContent":["import {simpleMode} from \"./simple-mode.js\"\n\nvar from = \"from\";\nvar fromRegex = new RegExp(\"^(\\\\s*)\\\\b(\" + from + \")\\\\b\", \"i\");\n\nvar shells = [\"run\", \"cmd\", \"entrypoint\", \"shell\"];\nvar shellsAsArrayRegex = new RegExp(\"^(\\\\s*)(\" + shells.join('|') + \")(\\\\s+\\\\[)\", \"i\");\n\nvar expose = \"expose\";\nvar exposeRegex = new RegExp(\"^(\\\\s*)(\" + expose + \")(\\\\s+)\", \"i\");\n\nvar others = [\n  \"arg\", \"from\", \"maintainer\", \"label\", \"env\",\n  \"add\", \"copy\", \"volume\", \"user\",\n  \"workdir\", \"onbuild\", \"stopsignal\", \"healthcheck\", \"shell\"\n];\n\n// Collect all Dockerfile directives\nvar instructions = [from, expose].concat(shells).concat(others),\n    instructionRegex = \"(\" + instructions.join('|') + \")\",\n    instructionOnlyLine = new RegExp(\"^(\\\\s*)\" + instructionRegex + \"(\\\\s*)(#.*)?$\", \"i\"),\n    instructionWithArguments = new RegExp(\"^(\\\\s*)\" + instructionRegex + \"(\\\\s+)\", \"i\");\n\nexport const dockerFile = simpleMode({\n  start: [\n    // Block comment: This is a line starting with a comment\n    {\n      regex: /^\\s*#.*$/,\n      sol: true,\n      token: \"comment\"\n    },\n    {\n      regex: fromRegex,\n      token: [null, \"keyword\"],\n      sol: true,\n      next: \"from\"\n    },\n    // Highlight an instruction without any arguments (for convenience)\n    {\n      regex: instructionOnlyLine,\n      token: [null, \"keyword\", null, \"error\"],\n      sol: true\n    },\n    {\n      regex: shellsAsArrayRegex,\n      token: [null, \"keyword\", null],\n      sol: true,\n      next: \"array\"\n    },\n    {\n      regex: exposeRegex,\n      token: [null, \"keyword\", null],\n      sol: true,\n      next: \"expose\"\n    },\n    // Highlight an instruction followed by arguments\n    {\n      regex: instructionWithArguments,\n      token: [null, \"keyword\", null],\n      sol: true,\n      next: \"arguments\"\n    },\n    {\n      regex: /./,\n      token: null\n    }\n  ],\n  from: [\n    {\n      regex: /\\s*$/,\n      token: null,\n      next: \"start\"\n    },\n    {\n      // Line comment without instruction arguments is an error\n      regex: /(\\s*)(#.*)$/,\n      token: [null, \"error\"],\n      next: \"start\"\n    },\n    {\n      regex: /(\\s*\\S+\\s+)(as)/i,\n      token: [null, \"keyword\"],\n      next: \"start\"\n    },\n    // Fail safe return to start\n    {\n      token: null,\n      next: \"start\"\n    }\n  ],\n  single: [\n    {\n      regex: /(?:[^\\\\']|\\\\.)/,\n      token: \"string\"\n    },\n    {\n      regex: /'/,\n      token: \"string\",\n      pop: true\n    }\n  ],\n  double: [\n    {\n      regex: /(?:[^\\\\\"]|\\\\.)/,\n      token: \"string\"\n    },\n    {\n      regex: /\"/,\n      token: \"string\",\n      pop: true\n    }\n  ],\n  array: [\n    {\n      regex: /\\]/,\n      token: null,\n      next: \"start\"\n    },\n    {\n      regex: /\"(?:[^\\\\\"]|\\\\.)*\"?/,\n      token: \"string\"\n    }\n  ],\n  expose: [\n    {\n      regex: /\\d+$/,\n      token: \"number\",\n      next: \"start\"\n    },\n    {\n      regex: /[^\\d]+$/,\n      token: null,\n      next: \"start\"\n    },\n    {\n      regex: /\\d+/,\n      token: \"number\"\n    },\n    {\n      regex: /[^\\d]+/,\n      token: null\n    },\n    // Fail safe return to start\n    {\n      token: null,\n      next: \"start\"\n    }\n  ],\n  arguments: [\n    {\n      regex: /^\\s*#.*$/,\n      sol: true,\n      token: \"comment\"\n    },\n    {\n      regex: /\"(?:[^\\\\\"]|\\\\.)*\"?$/,\n      token: \"string\",\n      next: \"start\"\n    },\n    {\n      regex: /\"/,\n      token: \"string\",\n      push: \"double\"\n    },\n    {\n      regex: /'(?:[^\\\\']|\\\\.)*'?$/,\n      token: \"string\",\n      next: \"start\"\n    },\n    {\n      regex: /'/,\n      token: \"string\",\n      push: \"single\"\n    },\n    {\n      regex: /[^#\"']+[\\\\`]$/,\n      token: null\n    },\n    {\n      regex: /[^#\"']+$/,\n      token: null,\n      next: \"start\"\n    },\n    {\n      regex: /[^#\"']+/,\n      token: null\n    },\n    // Fail safe return to start\n    {\n      token: null,\n      next: \"start\"\n    }\n  ],\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n});\n\n","export function simpleMode(states) {\n  ensureState(states, \"start\");\n  var states_ = {}, meta = states.languageData || {}, hasIndentation = false;\n  for (var state in states) if (state != meta && states.hasOwnProperty(state)) {\n    var list = states_[state] = [], orig = states[state];\n    for (var i = 0; i < orig.length; i++) {\n      var data = orig[i];\n      list.push(new Rule(data, states));\n      if (data.indent || data.dedent) hasIndentation = true;\n    }\n  }\n  return {\n    name: meta.name,\n    startState: function() {\n      return {state: \"start\", pending: null, indent: hasIndentation ? [] : null};\n    },\n    copyState: function(state) {\n      var s = {state: state.state, pending: state.pending, indent: state.indent && state.indent.slice(0)};\n      if (state.stack)\n        s.stack = state.stack.slice(0);\n      return s;\n    },\n    token: tokenFunction(states_),\n    indent: indentFunction(states_, meta),\n    languageData: meta\n  }\n};\n\nfunction ensureState(states, name) {\n  if (!states.hasOwnProperty(name))\n    throw new Error(\"Undefined state \" + name + \" in simple mode\");\n}\n\nfunction toRegex(val, caret) {\n  if (!val) return /(?:)/;\n  var flags = \"\";\n  if (val instanceof RegExp) {\n    if (val.ignoreCase) flags = \"i\";\n    val = val.source;\n  } else {\n    val = String(val);\n  }\n  return new RegExp((caret === false ? \"\" : \"^\") + \"(?:\" + val + \")\", flags);\n}\n\nfunction asToken(val) {\n  if (!val) return null;\n  if (val.apply) return val\n  if (typeof val == \"string\") return val.replace(/\\./g, \" \");\n  var result = [];\n  for (var i = 0; i < val.length; i++)\n    result.push(val[i] && val[i].replace(/\\./g, \" \"));\n  return result;\n}\n\nfunction Rule(data, states) {\n  if (data.next || data.push) ensureState(states, data.next || data.push);\n  this.regex = toRegex(data.regex);\n  this.token = asToken(data.token);\n  this.data = data;\n}\n\nfunction tokenFunction(states) {\n  return function(stream, state) {\n    if (state.pending) {\n      var pend = state.pending.shift();\n      if (state.pending.length == 0) state.pending = null;\n      stream.pos += pend.text.length;\n      return pend.token;\n    }\n\n    var curState = states[state.state];\n    for (var i = 0; i < curState.length; i++) {\n      var rule = curState[i];\n      var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);\n      if (matches) {\n        if (rule.data.next) {\n          state.state = rule.data.next;\n        } else if (rule.data.push) {\n          (state.stack || (state.stack = [])).push(state.state);\n          state.state = rule.data.push;\n        } else if (rule.data.pop && state.stack && state.stack.length) {\n          state.state = state.stack.pop();\n        }\n\n        if (rule.data.indent)\n          state.indent.push(stream.indentation() + stream.indentUnit);\n        if (rule.data.dedent)\n          state.indent.pop();\n        var token = rule.token\n        if (token && token.apply) token = token(matches)\n        if (matches.length > 2 && rule.token && typeof rule.token != \"string\") {\n          state.pending = [];\n          for (var j = 2; j < matches.length; j++)\n            if (matches[j])\n              state.pending.push({text: matches[j], token: rule.token[j - 1]});\n          stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));\n          return token[0];\n        } else if (token && token.join) {\n          return token[0];\n        } else {\n          return token;\n        }\n      }\n    }\n    stream.next();\n    return null;\n  };\n}\n\nfunction indentFunction(states, meta) {\n  return function(state, textAfter) {\n    if (state.indent == null || meta.dontIndentStates && meta.doneIndentState.indexOf(state.state) > -1)\n      return null\n\n    var pos = state.indent.length - 1, rules = states[state.state];\n    scan: for (;;) {\n      for (var i = 0; i < rules.length; i++) {\n        var rule = rules[i];\n        if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {\n          var m = rule.regex.exec(textAfter);\n          if (m && m[0]) {\n            pos--;\n            if (rule.next || rule.push) rules = states[rule.next || rule.push];\n            textAfter = textAfter.slice(m[0].length);\n            continue scan;\n          }\n        }\n      }\n      break;\n    }\n    return pos < 0 ? 0 : state.indent[pos];\n  };\n}\n"],"names":["from","fromRegex","shells","shellsAsArrayRegex","join","expose","exposeRegex","instructionRegex","instructions","concat","instructionOnlyLine","instructionWithArguments","dockerFile","_simple_mode_js__WEBPACK_IMPORTED_MODULE_0__","Q","start","regex","sol","token","next","single","pop","double","array","arguments","push","languageData","commentTokens","line","simpleMode","states","ensureState","states_","meta","hasIndentation","state","hasOwnProperty","list","orig","i","length","data","Rule","indent","dedent","name","startState","pending","copyState","s","slice","stack","stream","pend","shift","pos","text","curState","rule","matches","match","indentation","indentUnit","apply","j","backUp","textAfter","dontIndentStates","doneIndentState","indexOf","rules","scan","dedentIfLineStart","m","exec","toRegex","val","caret","flags","RegExp","ignoreCase","source","String","asToken","replace","result"],"sourceRoot":""}