{"version":3,"file":"static/chunks/d2094a0f-597f5f5153af1363.js","mappings":"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","sources":["webpack://_N_E/./node_modules/slate-react/dist/index.es.js","webpack://_N_E/<anon>"],"sourcesContent":["import getDirection from 'direction';\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nimport React, { useLayoutEffect, useEffect, useRef, createContext, useContext, useCallback, Component, useState, useReducer, useMemo } from 'react';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport { Editor, Scrubber, Transforms, Range, Path, Node, Text as Text$1, Element as Element$1, Point } from 'slate';\nimport { isKeyHotkey } from 'is-hotkey';\nimport ReactDOM from 'react-dom';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n/**\r\n * An auto-incrementing identifier for keys.\r\n */\nvar n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */\n\nclass Key {\n  constructor() {\n    this.id = \"\".concat(n++);\n  }\n\n}\n\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */\n\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_STYLE_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */\n\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */\n\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */\n\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */\n\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */\n\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n/**\r\n * Types.\r\n */\nvar DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */\n\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */\n\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */\n\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */\n\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */\n\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */\n\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward'); // If the editable child found is in front of input offset, we instead seek to its end\n\n    isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return [node, offset];\n};\n/**\r\n * Determines wether the active element is nested within a shadowRoot\r\n */\n\nvar hasShadowRoot = node => {\n  var parent = node && node.parentNode;\n\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return false;\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n\n  return [child, index];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */\n\nvar getPlainText = domNode => {\n  var text = '';\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n\n  return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */\n\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */\n\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n\n  var {\n    document\n  } = ReactEditor.getWindow(editor);\n\n  if (document.contains(target)) {\n    return ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n\n\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n\nvar IS_REACT_VERSION_17_OR_ABOVE = parseInt(React.version.split('.')[0], 10) >= 17;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\n\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\n\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\n\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // UC mobile browser\n\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser\n\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent); // Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\n\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined'); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\n\nvar HAS_BEFORE_INPUT_SUPPORT = !IS_CHROME_LEGACY && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nvar ReactEditor = {\n  /**\r\n   * Check if the user is currently composing inside the editor.\r\n   */\n  isComposing(editor) {\n    return !!IS_COMPOSING.get(editor);\n  },\n\n  /**\r\n   * Return the host window of the current editor.\r\n   */\n  getWindow(editor) {\n    var window = EDITOR_TO_WINDOW.get(editor);\n\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n\n    return window;\n  },\n\n  /**\r\n   * Find a key for a Slate node.\r\n   */\n  findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n\n    return key;\n  },\n\n  /**\r\n   * Find the path of Slate node.\r\n   */\n  findPath(editor, node) {\n    var path = [];\n    var child = node;\n\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n\n      var i = NODE_TO_INDEX.get(child);\n\n      if (i == null) {\n        break;\n      }\n\n      path.unshift(i);\n      child = parent;\n    }\n\n    throw new Error(\"Unable to find the path for Slate node: \".concat(Scrubber.stringify(node)));\n  },\n\n  /**\r\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\r\n   */\n  findDocumentOrShadowRoot(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n\n    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n      return root;\n    }\n\n    return el.ownerDocument;\n  },\n\n  /**\r\n   * Check if the editor is focused.\r\n   */\n  isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n\n  /**\r\n   * Check if the editor is in read-only mode.\r\n   */\n  isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n\n  /**\r\n   * Blur the editor.\r\n   */\n  blur(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n\n  /**\r\n   * Focus the editor.\r\n   */\n  focus(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, true);\n\n    if (root.activeElement !== el) {\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n\n  /**\r\n   * Deselect the editor.\r\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n\n    if (selection) {\n      Transforms.deselect(editor);\n    }\n  },\n\n  /**\r\n   * Check if a DOM node is within the editor.\r\n   */\n  hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = ReactEditor.toDOMNode(editor, editor);\n    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n\n    if (!targetEl) {\n      return false;\n    }\n\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n\n  /**\r\n   * Insert data from a `DataTransfer` into the editor.\r\n   */\n  insertData(editor, data) {\n    editor.insertData(data);\n  },\n\n  /**\r\n   * Insert fragment data from a `DataTransfer` into the editor.\r\n   */\n  insertFragmentData(editor, data) {\n    return editor.insertFragmentData(data);\n  },\n\n  /**\r\n   * Insert text data from a `DataTransfer` into the editor.\r\n   */\n  insertTextData(editor, data) {\n    return editor.insertTextData(data);\n  },\n\n  /**\r\n   * Sets data from the currently selected fragment on a `DataTransfer`.\r\n   */\n  setFragmentData(editor, data, originEvent) {\n    editor.setFragmentData(data, originEvent);\n  },\n\n  /**\r\n   * Find the native DOM element from a Slate node.\r\n   */\n  toDOMNode(editor, node) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(Scrubber.stringify(node)));\n    }\n\n    return domNode;\n  },\n\n  /**\r\n   * Find a native DOM selection point from a Slate point.\r\n   */\n  toDOMPoint(editor, point) {\n    var [node] = Editor.node(editor, point.path);\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n\n    if (Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    } // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n\n\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n\n      var nextText = texts[i + 1];\n\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n\n        var domText = nextText.childNodes[0];\n        domPoint = [// COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n\n      start = end;\n    }\n\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(Scrubber.stringify(point)));\n    }\n\n    return domPoint;\n  },\n\n  /**\r\n   * Find a native DOM range from a Slate `range`.\r\n   *\r\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\r\n   *\r\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\r\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\r\n   */\n  toDOMRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = Range.isBackward(range);\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var window = ReactEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n\n  /**\r\n   * Find a Slate node from a native DOM `element`.\r\n   */\n  toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Get the target range from a DOM `event`.\r\n   */\n  findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n\n    if (Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n\n      if (point) {\n        var _range = Editor.range(editor, point);\n\n        return _range;\n      }\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var domRange;\n    var {\n      document\n    } = ReactEditor.getWindow(editor); // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n\n  /**\r\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\r\n   */\n  toSlatePoint(editor, domPoint, options) {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n\n      var editorEl = ReactEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n\n        if (textNode) {\n          var window = ReactEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n\n              return;\n            }\n\n            el.parentNode.removeChild(el);\n          }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n\n          if (ReactEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        } // COMPAT: In read-only editors the leaf is not rendered.\n\n\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      }\n\n      if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (parentNode.hasAttribute('data-slate-zero-width') || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n\n      if (node && ReactEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = ReactEditor.toSlateNode(editor, node);\n\n        var {\n          path: _path,\n          offset: _offset\n        } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));\n\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    } // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n\n\n    var slateNode = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n\n  /**\r\n   * Find a Slate range from a DOM range or selection.\r\n   */\n  toSlateRange(editor, domRange, options) {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode;\n        anchorOffset = domRange.anchorOffset;\n        focusNode = domRange.focusNode;\n        focusOffset = domRange.focusOffset; // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n\n        if (IS_CHROME && hasShadowRoot(anchorNode)) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n\n    if (!anchor) {\n      return null;\n    }\n\n    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow\n    });\n\n    if (!focus) {\n      return null;\n    }\n\n    var range = {\n      anchor: anchor,\n      focus: focus\n    }; // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n\n    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n\n    return range;\n  },\n\n  hasRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);\n  },\n\n  /**\r\n   * Check if the target is in the editor.\r\n   */\n  hasTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n  },\n\n  /**\r\n   * Check if the target is editable and in the editor.\r\n   */\n  hasEditableTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  },\n\n  /**\r\n   * Check if the target can be selectable\r\n   */\n  hasSelectableTarget(editor, target) {\n    return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);\n  },\n\n  /**\r\n   * Check if the target is inside void and in an non-readonly editor.\r\n   */\n  isTargetInsideNonReadonlyVoid(editor, target) {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n    return Editor.isVoid(editor, slateNode);\n  },\n\n  /**\r\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\r\n   */\n  androidScheduleFlush(editor) {\n    var _EDITOR_TO_SCHEDULE_F;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n  },\n\n  /**\r\n   * Experimental and android specific: Get pending diffs\r\n   */\n  androidPendingDiffs(editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor);\n  }\n\n};\n\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */\n\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\nvar _excluded$3 = [\"anchor\", \"focus\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\nvar isDecoratorRangeListEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n\n    var rangeOwnProps = _objectWithoutProperties(range, _excluded$3);\n\n    var otherOwnProps = _objectWithoutProperties(other, _excluded2$1);\n\n    if (!Range.equals(range, other) || range[PLACEHOLDER_SYMBOL] !== other[PLACEHOLDER_SYMBOL] || !shallowCompare(rangeOwnProps, otherOwnProps)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\r\n * Leaf content strings.\r\n */\n\nvar String = props => {\n  var {\n    isLast,\n    leaf,\n    parent,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = Path.parent(path);\n  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      length: Node.string(parent).length\n    });\n  } // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n\n\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n\n\n  if (leaf.text === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n\n\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/React.createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\r\n * Leaf strings with text in them.\r\n */\n\n\nvar TextString = props => {\n  var {\n    text,\n    isTrailing = false\n  } = props;\n  var ref = useRef(null);\n\n  var getTextContent = () => {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  }; // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n\n\n  useIsomorphicLayoutEffect(() => {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n\n  }); // Render text content immediately if it's the first-time render\n  // Ensure that text content is rendered on server-side rendering\n\n  if (!ref.current) {\n    return /*#__PURE__*/React.createElement(\"span\", {\n      \"data-slate-string\": true,\n      ref: ref\n    }, getTextContent());\n  } // the span is intentionally same on every render in virtual DOM, actual rendering happens in the layout effect above\n\n\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  });\n};\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */\n\n\nvar ZeroWidthString = props => {\n  var {\n    length = 0,\n    isLineBreak = false,\n    isMarkPlaceholder = false\n  } = props;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n\n  return /*#__PURE__*/React.createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? '\\uFEFF' : null, isLineBreak ? /*#__PURE__*/React.createElement(\"br\", null) : null);\n};\n\n/**\r\n * A React context for sharing the editor object.\r\n */\n\nvar EditorContext = /*#__PURE__*/createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlateStatic = () => {\n  var editor = useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */\n\nvar Leaf = props => {\n  var {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = props => /*#__PURE__*/React.createElement(DefaultLeaf, Object.assign({}, props))\n  } = props;\n  var placeholderRef = useRef(null);\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = useRef(null);\n  useEffect(() => {\n    return () => {\n      if (placeholderResizeObserver.current) {\n        placeholderResizeObserver.current.disconnect();\n      }\n    };\n  }, []);\n  useEffect(() => {\n    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;\n\n    if (placeholderEl) {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n    } else {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n    }\n\n    if (placeholderResizeObserver.current) {\n      // Update existing observer.\n      placeholderResizeObserver.current.disconnect();\n      if (placeholderEl) placeholderResizeObserver.current.observe(placeholderEl);\n    } else if (placeholderEl) {\n      // Create a new observer and observe the placeholder element.\n      placeholderResizeObserver.current = new ResizeObserver(_ref => {\n        var [{\n          target\n        }] = _ref;\n        var styleElement = EDITOR_TO_STYLE_ELEMENT.get(editor);\n\n        if (styleElement) {\n          // Make the min-height the height of the placeholder.\n          var minHeight = \"\".concat(target.clientHeight, \"px\");\n          styleElement.innerHTML = \":where([data-slate-editor-id=\\\"\".concat(editor.id, \"\\\"]) { min-height: \").concat(minHeight, \"; }\");\n        }\n      });\n      placeholderResizeObserver.current.observe(placeholderEl);\n    }\n\n    if (!placeholderEl) {\n      // No placeholder element, so no need for a resize observer.\n      var styleElement = EDITOR_TO_STYLE_ELEMENT.get(editor);\n\n      if (styleElement) {\n        // No min-height if there is no placeholder.\n        styleElement.innerHTML = '';\n      }\n    }\n\n    return () => {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n    };\n  }, [placeholderRef, leaf]);\n  var children = /*#__PURE__*/React.createElement(String, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n\n  if (leaf[PLACEHOLDER_SYMBOL]) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none'\n        },\n        contentEditable: false,\n        ref: placeholderRef\n      }\n    };\n    children = /*#__PURE__*/React.createElement(React.Fragment, null, renderPlaceholder(placeholderProps), children);\n  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n\n\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text\n  });\n};\n\nvar MemoizedLeaf = /*#__PURE__*/React.memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && Text$1.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/React.createElement(\"span\", Object.assign({}, attributes), children);\n};\n\n/**\r\n * Text.\r\n */\n\nvar Text = props => {\n  var {\n    decorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var ref = useRef(null);\n  var leaves = Text$1.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/React.createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  useIsomorphicLayoutEffect(() => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (ref.current) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(text, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text);\n    }\n  });\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: ref\n  }, children);\n};\n\nvar MemoizedText = /*#__PURE__*/React.memo(Text, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && isDecoratorRangeListEqual(next.decorations, prev.decorations);\n});\n\n/**\r\n * Element.\r\n */\n\nvar Element = props => {\n  var {\n    decorations,\n    element,\n    renderElement = p => /*#__PURE__*/React.createElement(DefaultElement, Object.assign({}, p)),\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = useCallback(ref => {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n      NODE_TO_ELEMENT.set(element, ref);\n      ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  }); // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n\n  var attributes = {\n    'data-slate-node': 'element',\n    ref\n  };\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  } // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n\n\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    var text = Node.string(element);\n    var dir = getDirection(text);\n\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  } // If it's a void node, wrap the children in extra void-specific elements.\n\n\n  if (Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n\n    var Tag = isInline ? 'span' : 'div';\n    var [[_text]] = Node.texts(element);\n    children = /*#__PURE__*/React.createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/React.createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  }\n\n  return renderElement({\n    attributes,\n    children,\n    element\n  });\n};\n\nvar MemoizedElement = /*#__PURE__*/React.memo(Element, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isDecoratorRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */\n\nvar DefaultElement = props => {\n  var {\n    attributes,\n    children,\n    element\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/React.createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */\n\nvar DecorateContext = /*#__PURE__*/createContext(() => []);\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */\n\nvar useDecorate = () => {\n  return useContext(DecorateContext);\n};\n\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */\n\nvar SelectedContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */\n\nvar useSelected = () => {\n  return useContext(SelectedContext);\n};\n\n/**\r\n * Children.\r\n */\n\nvar useChildren = props => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = Element$1.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = Editor.range(editor, p);\n    var sel = selection && Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n\n    for (var dec of decorations) {\n      var d = Range.intersection(dec, range);\n\n      if (d) {\n        ds.push(d);\n      }\n    }\n\n    if (Element$1.isElement(n)) {\n      children.push( /*#__PURE__*/React.createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /*#__PURE__*/React.createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: sel\n      })));\n    } else {\n      children.push( /*#__PURE__*/React.createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n\n  return children;\n};\n\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */\n\nvar ReadOnlyContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */\n\nvar useReadOnly = () => {\n  return useContext(ReadOnlyContext);\n};\n\nvar SlateContext = /*#__PURE__*/createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlate = () => {\n  var context = useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var {\n    editor\n  } = context;\n  return editor;\n};\nvar useSlateWithV = () => {\n  var context = useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return context;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\r\n * Hotkey mappings for each platform.\r\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */\n\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isKeyHotkey(generic);\n  var isApple = apple && isKeyHotkey(apple);\n  var isWindows = windows && isKeyHotkey(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\r\n * Hotkeys.\r\n */\n\n\nvar Hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nvar createRestoreDomManager = (editor, receivedUserInput) => {\n  var bufferedMutations = [];\n\n  var clear = () => {\n    bufferedMutations = [];\n  };\n\n  var registerMutations = mutations => {\n    if (!receivedUserInput.current) {\n      return;\n    }\n\n    var trackedMutations = mutations.filter(mutation => isTrackedMutation(editor, mutation, mutations));\n    bufferedMutations.push(...trackedMutations);\n  };\n\n  function restoreDOM() {\n    bufferedMutations.reverse().forEach(mutation => {\n      if (mutation.type === 'characterData') {\n        mutation.target.textContent = mutation.oldValue;\n        return;\n      }\n\n      mutation.removedNodes.forEach(node => {\n        mutation.target.insertBefore(node, mutation.nextSibling);\n      });\n      mutation.addedNodes.forEach(node => {\n        mutation.target.removeChild(node);\n      });\n    }); // Clear buffered mutations to ensure we don't undo them twice\n\n    clear();\n  }\n\n  return {\n    registerMutations,\n    restoreDOM,\n    clear\n  };\n};\n\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\n\nclass RestoreDOMComponent extends Component {\n  constructor() {\n    super(...arguments);\n    this.context = null;\n    this.manager = null;\n    this.mutationObserver = null;\n  }\n\n  observe() {\n    var _this$mutationObserve;\n\n    var {\n      node\n    } = this.props;\n\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG$1);\n  }\n\n  componentDidMount() {\n    var {\n      receivedUserInput\n    } = this.props;\n    var editor = this.context;\n    this.manager = createRestoreDomManager(editor, receivedUserInput);\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n    this.observe();\n  }\n\n  getSnapshotBeforeUpdate() {\n    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n\n    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n\n    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n      var _this$manager;\n\n      (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n    }\n\n    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n    return null;\n  }\n\n  componentDidUpdate() {\n    var _this$manager3;\n\n    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n    this.observe();\n  }\n\n  componentWillUnmount() {\n    var _this$mutationObserve4;\n\n    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n  }\n\n  render() {\n    return this.props.children;\n  }\n\n}\n\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : _ref => {\n  var {\n    children\n  } = _ref;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n};\n\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */\n\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n\n  if (!Editor.hasPath(editor, path)) {\n    return false;\n  }\n\n  var node = Node.get(editor, path);\n\n  if (!Text$1.isText(node)) {\n    return false;\n  }\n\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n\n  var nextPath = Path.next(path);\n\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n\n  var nextNode = Node.get(editor, nextPath);\n  return Text$1.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\n\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\n\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */\n\n\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n\n  return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */\n\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */\n\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */\n\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n\n  if (!Editor.hasPath(editor, path)) {\n    return null;\n  }\n\n  var leaf = Node.get(editor, path);\n\n  if (!Text$1.isText(leaf)) {\n    return null;\n  }\n\n  var parentBlock = Editor.above(editor, {\n    match: n => Editor.isBlock(editor, n),\n    at: path\n  });\n\n  if (!parentBlock) {\n    return null;\n  }\n\n  while (offset > leaf.text.length) {\n    var entry = Editor.next(editor, {\n      at: path,\n      match: Text$1.isText\n    });\n\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n\n  return {\n    path,\n    offset\n  };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */\n\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = normalizePoint(editor, range.focus);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return Path.equals(path, point.path);\n  });\n\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n\n  var {\n    diff\n  } = textDiff; // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n\n    var _transformed = Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n\n    if (!_transformed) {\n      return null;\n    }\n\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  } // Point references location after the diff\n\n\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n\n  if (!transformed) {\n    return null;\n  }\n\n  if (op.type === 'split_node' && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = transformPendingPoint(editor, range.focus, op);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n\n    case 'remove_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n\n    case 'split_node':\n      {\n        if (!Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n\n    case 'merge_node':\n      {\n        if (!Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op)\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op)\n        };\n      }\n  }\n\n  var newPath = Path.transform(path, op);\n\n  if (!newPath) {\n    return null;\n  }\n\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\n\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\n\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\n\nvar debug = function debug() {};\n\nfunction createAndroidInputManager(_ref) {\n  var {\n    editor,\n    scheduleOnDOMSelectionChange,\n    onDOMSelectionChange\n  } = _ref;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n\n  var applyPendingSelection = () => {\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n\n    if (pendingSelection) {\n      var {\n        selection\n      } = editor;\n      var normalized = normalizeRange(editor, pendingSelection);\n\n      if (normalized && (!selection || !Range.equals(normalized, selection))) {\n        Transforms.select(editor, normalized);\n      }\n    }\n  };\n\n  var performAction = () => {\n    var action = EDITOR_TO_PENDING_ACTION.get(editor);\n    EDITOR_TO_PENDING_ACTION.delete(editor);\n\n    if (!action) {\n      return;\n    }\n\n    if (action.at) {\n      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n\n      if (!target) {\n        return;\n      }\n\n      var _targetRange = Editor.range(editor, target);\n\n      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {\n        Transforms.select(editor, target);\n      }\n    }\n\n    action.run();\n  };\n\n  var flush = () => {\n    var _EDITOR_TO_PENDING_DI;\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n\n    if (!flushing) {\n      flushing = true;\n      setTimeout(() => flushing = false);\n    }\n\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n\n    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = !!((_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length);\n    var diff;\n\n    while (diff = (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2[0]) {\n      var _EDITOR_TO_PENDING_DI2, _EDITOR_TO_PENDING_DI3;\n\n      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n\n      if (pendingMarks !== undefined) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n\n      var range = targetRange(diff);\n\n      if (!editor.selection || !Range.equals(editor.selection, range)) {\n        Transforms.select(editor, range);\n      }\n\n      if (diff.diff.text) {\n        Editor.insertText(editor, diff.diff.text);\n      } else {\n        Editor.deleteFragment(editor);\n      } // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n\n\n      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI3 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI3.filter(_ref2 => {\n        var {\n          id\n        } = _ref2;\n        return id !== diff.id;\n      }));\n\n      if (!verifyDiffState(editor, diff)) {\n        scheduleSelectionChange = false;\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = 'action'; // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n      }\n    }\n\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n\n    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {\n      Transforms.select(editor, selection);\n    }\n\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    } // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n\n\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n    EDITOR_TO_USER_MARKS.delete(editor);\n\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n\n  var handleCompositionEnd = _event => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n\n    compositionEndTimeoutId = setTimeout(() => {\n      IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n\n  var handleCompositionStart = _event => {\n    IS_COMPOSING.set(editor, true);\n\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n\n    if (!placeholderElement) {\n      return;\n    }\n\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n\n    placeholderElement.style.removeProperty('display');\n  };\n\n  var storeDiff = (path, diff) => {\n    var _EDITOR_TO_PENDING_DI4;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 ? _EDITOR_TO_PENDING_DI4 : [];\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(change => Path.equals(change.path, path));\n\n    if (idx < 0) {\n      var normalized = normalizeStringDiff(target.text, diff);\n\n      if (normalized) {\n        pendingDiffs.push({\n          path,\n          diff,\n          id: idCounter++\n        });\n      }\n\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    pendingDiffs[idx] = _objectSpread$3(_objectSpread$3({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n\n  var scheduleAction = function scheduleAction(run) {\n    var {\n      at\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    insertPositionHint = false;\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n\n    if (hasPendingAction()) {\n      flush();\n    }\n\n    EDITOR_TO_PENDING_ACTION.set(editor, {\n      at,\n      run\n    }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n\n    actionTimeoutId = setTimeout(flush);\n  };\n\n  var handleDOMBeforeInput = event => {\n    var _targetRange2;\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var {\n      inputType: type\n    } = event;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n\n    var [nativeTargetRange] = event.getTargetRanges();\n\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    } // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n\n\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n\n    if (!targetRange) {\n      return;\n    }\n\n    if (Range.isExpanded(targetRange) && type.startsWith('delete')) {\n      var [start, end] = Range.edges(targetRange);\n      var leaf = Node.leaf(editor, start.path);\n\n      if (leaf.text.length === start.offset && end.offset === 0) {\n        var next = Editor.next(editor, {\n          at: start.path,\n          match: Text$1.isText\n        });\n\n        if (next && Path.equals(next[1], end.path)) {\n          targetRange = {\n            anchor: end,\n            focus: end\n          };\n        }\n      }\n    }\n\n    if (Range.isExpanded(targetRange) && type.startsWith('delete')) {\n      if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n        var [_start, _end] = Range.edges(targetRange);\n        return storeDiff(targetRange.anchor.path, {\n          text: '',\n          end: _end.offset,\n          start: _start.offset\n        });\n      }\n\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n      return scheduleAction(() => Editor.deleteFragment(editor, {\n        direction\n      }), {\n        at: targetRange\n      });\n    }\n\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(() => Editor.deleteFragment(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var {\n            anchor\n          } = targetRange;\n\n          if (Range.isCollapsed(targetRange)) {\n            var targetNode = Node.leaf(editor, anchor.path);\n\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n\n          return scheduleAction(() => Editor.deleteForward(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n\n          var {\n            anchor: _anchor\n          } = targetRange; // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n\n          var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n\n          if (nativeCollapsed && Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n\n          return scheduleAction(() => Editor.deleteBackward(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(() => {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'insertLineBreak':\n        {\n          return scheduleAction(() => Editor.insertSoftBreak(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'insertParagraph':\n        {\n          return scheduleAction(() => Editor.insertBreak(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n            return scheduleAction(() => ReactEditor.insertData(editor, data), {\n              at: targetRange\n            });\n          }\n\n          if (typeof data === 'string' && data.includes('\\n')) {\n            return scheduleAction(() => Editor.insertSoftBreak(editor), {\n              at: Range.end(targetRange)\n            });\n          }\n\n          var text = data !== null && data !== void 0 ? data : ''; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n\n          if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            text = text.replace('\\uFEFF', '');\n          }\n\n          if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var [_start2, _end2] = Range.edges(targetRange);\n            var diff = {\n              start: _start2.offset,\n              end: _end2.offset,\n              text\n            }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n\n            if (text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n              var diffPosition = diff.start + diff.text.search(/\\S|$/);\n\n              if (diffPosition === hintPosition + 1 && diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = diff;\n              } else if (insertPositionHint && Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                insertPositionHint = _objectSpread$3(_objectSpread$3({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n\n            storeDiff(_start2.path, diff);\n            return;\n          }\n\n          return scheduleAction(() => Editor.insertText(editor, text), {\n            at: targetRange\n          });\n        }\n    }\n  };\n\n  var hasPendingAction = () => {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n\n  var hasPendingDiffs = () => {\n    var _EDITOR_TO_PENDING_DI5;\n\n    return !!((_EDITOR_TO_PENDING_DI5 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI5 !== void 0 && _EDITOR_TO_PENDING_DI5.length);\n  };\n\n  var hasPendingChanges = () => {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n\n  var isFlushing = () => {\n    return flushing;\n  };\n\n  var handleUserSelect = range => {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range);\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var {\n      selection\n    } = editor;\n\n    if (!range) {\n      return;\n    }\n\n    var pathChanged = !selection || !Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n\n    if (pathChanged || !hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n\n  var handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n\n  var handleKeyDown = _ => {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n\n  var scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n\n  var handleDomMutations = mutations => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n\n    if (mutations.some(mutation => isTrackedMutation(editor, mutation, mutations))) {\n      var _EDITOR_TO_FORCE_REND;\n\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n    }\n  };\n\n  return {\n    flush,\n    scheduleFlush,\n    hasPendingDiffs,\n    hasPendingAction,\n    hasPendingChanges,\n    isFlushing,\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleKeyDown,\n    handleDomMutations,\n    handleInput\n  };\n}\n\nfunction useIsMounted() {\n  var isMountedRef = useRef(false);\n  useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\n\nfunction useMutationObserver(node, callback, options) {\n  var [mutationObserver] = useState(() => new MutationObserver(callback));\n  useIsomorphicLayoutEffect(() => {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  useEffect(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    mutationObserver.observe(node.current, options);\n    return () => mutationObserver.disconnect();\n  }, []);\n}\n\nvar _excluded$2 = [\"node\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nfunction useAndroidInputManager(_ref) {\n  var {\n    node\n  } = _ref,\n      options = _objectWithoutProperties(_ref, _excluded$2);\n\n  if (!IS_ANDROID) {\n    return null;\n  }\n\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var [inputManager] = useState(() => createAndroidInputManager(_objectSpread$2({\n    editor\n  }, options)));\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);\n  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n\n  if (isMounted) {\n    inputManager.flush();\n  }\n\n  return inputManager;\n}\n\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = useRef(false);\n  var animationFrameIdRef = useRef(0);\n  var onUserInput = useCallback(() => {\n    if (receivedUserInput.current) {\n      return;\n    }\n\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => {\n      receivedUserInput.current = false;\n    });\n  }, []);\n  useEffect(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);\n  return {\n    receivedUserInput,\n    onUserInput\n  };\n}\n\nvar _excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\"],\n    _excluded2 = [\"text\"];\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Children = props => /*#__PURE__*/React.createElement(React.Fragment, null, useChildren(props)); // The number of Editable components currently mounted.\n\n\nvar mountedCount = 0;\n/**\r\n * Editable.\r\n */\n\nvar Editable = props => {\n  var {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    renderPlaceholder = props => /*#__PURE__*/React.createElement(DefaultPlaceholder, Object.assign({}, props)),\n    scrollSelectionIntoView = defaultScrollSelectionIntoView,\n    style = {},\n    as: Component = 'div'\n  } = props,\n      attributes = _objectWithoutProperties(props, _excluded$1);\n\n  var editor = useSlate(); // Rerender editor when composition status changed\n\n  var [isComposing, setIsComposing] = useState(false);\n  var ref = useRef(null);\n  var deferredOperations = useRef([]);\n  var {\n    onUserInput,\n    receivedUserInput\n  } = useTrackUserInput();\n  var [, forceRender] = useReducer(s => s + 1, 0);\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n\n  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n\n  var state = useMemo(() => ({\n    isDraggingInternally: false,\n    isUpdatingSelection: false,\n    latestElement: null,\n    hasMarkPlaceholder: false\n  }), []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n\n  useEffect(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]); // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n\n  var onDOMSelectionChange = useCallback(throttle(() => {\n    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = root;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = root.getSelection();\n\n      if (activeElement === el) {\n        state.latestElement = activeElement;\n        IS_FOCUSED.set(editor, true);\n      } else {\n        IS_FOCUSED.delete(editor);\n      }\n\n      if (!domSelection) {\n        return Transforms.deselect(editor);\n      }\n\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n      var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n\n      if (anchorNodeSelectable && focusNodeSelectable) {\n        var range = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n\n        if (range) {\n          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n            Transforms.select(editor, range);\n          } else {\n            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n          }\n        }\n      } // Deselect the editor if the dom selection is not selectable in readonly mode\n\n\n      if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n        Transforms.deselect(editor);\n      }\n    }\n  }, 100), [readOnly]);\n  var scheduleOnDOMSelectionChange = useMemo(() => debounce(onDOMSelectionChange, 0), [onDOMSelectionChange]);\n  var androidInputManager = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(() => {\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    } // Make sure the DOM selection state is in sync.\n\n\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {\n      return;\n    }\n\n    var setDomSelection = forceChange => {\n      var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.\n\n      if (!selection && !hasDomSelection) {\n        return;\n      } // verify that the dom selection is in the editor\n\n\n      var editorElement = EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n\n      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {\n        hasDomSelectionInEditor = true;\n      } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n\n\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n\n        if (slateRange && Range.equals(slateRange, selection)) {\n          var _anchorNode$parentEle;\n\n          if (!state.hasMarkPlaceholder) {\n            return;\n          } // Ensure selection is inside the mark placeholder\n\n\n          var {\n            anchorNode\n          } = domSelection;\n\n          if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      } // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n\n\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      } // Otherwise the DOM selection is out of sync, so update it.\n\n\n      state.isUpdatingSelection = true;\n      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n\n      if (newDomRange) {\n        if (Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n\n      return newDomRange;\n    };\n\n    var newDomRange = setDomSelection();\n    var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === 'action';\n\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (newDomRange && IS_FIREFOX) {\n          var el = ReactEditor.toDOMNode(editor, editor);\n          el.focus();\n        }\n\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        var ensureDomSelection = forceChange => {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {// Ignore, dom and state might be out of sync\n          }\n        }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n\n\n        ensureDomSelection();\n        timeoutId = setTimeout(() => {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n\n  var onDOMBeforeInput = useCallback(event => {\n    onUserInput();\n\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManager) {\n        return androidInputManager.handleDOMBeforeInput(event);\n      } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n\n\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText'; // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n\n      var native = false;\n\n      if (type === 'insertText' && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        var _node$parentElement, _window$getComputedSt;\n\n        native = true; // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n\n        if (editor.marks) {\n          native = false;\n        } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n        // Therefore we don't allow native events to insert text at the end of anchor nodes.\n\n\n        var {\n          anchor\n        } = selection;\n        var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n        var window = ReactEditor.getWindow(editor);\n\n        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n          var _lastText$textContent;\n\n          // Find the last text node inside the anchor.\n          var lastText = window === null || window === void 0 ? void 0 : window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n\n          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n            native = false;\n          }\n        } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n        // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n\n\n        if (native && node.parentElement && (window === null || window === void 0 ? void 0 : (_window$getComputedSt = window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n          var block = Editor.above(editor, {\n            at: anchor.path,\n            match: n => Editor.isBlock(editor, n)\n          });\n\n          if (block && Node.string(block[0]).includes('\\t')) {\n            native = false;\n          }\n        }\n      } // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n\n\n      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n        var [targetRange] = event.getTargetRanges();\n\n        if (targetRange) {\n          var range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n\n          if (!selection || !Range.equals(selection, range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);\n            Transforms.select(editor, range);\n\n            if (selectionRef) {\n              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      } // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n\n\n      if (isCompositionChange) {\n        return;\n      }\n\n      if (!native) {\n        event.preventDefault();\n      } // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n\n\n      if (selection && Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            Editor.deleteFragment(editor);\n            break;\n          }\n\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            Editor.deleteForward(editor);\n            break;\n          }\n\n        case 'deleteContentBackward':\n          {\n            Editor.deleteBackward(editor);\n            break;\n          }\n\n        case 'deleteEntireSoftLine':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteWordBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'deleteWordForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'insertLineBreak':\n          Editor.insertSoftBreak(editor);\n          break;\n\n        case 'insertParagraph':\n          {\n            Editor.insertBreak(editor);\n            break;\n          }\n\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                IS_COMPOSING.set(editor, false);\n              }\n            } // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n\n\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(() => Editor.insertText(editor, data));\n              } else {\n                Editor.insertText(editor, data);\n              }\n            }\n\n            break;\n          }\n      } // Restore the actual user section if nothing manually set it.\n\n\n      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      EDITOR_TO_USER_SELECTION.delete(editor);\n\n      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {\n        Transforms.select(editor, toRestore);\n      }\n    }\n  }, [readOnly, propsOnDOMBeforeInput]); // Attach a native DOM event handler for `beforeinput` events, because React's\n  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n  // real `beforeinput` events sadly... (2019/11/04)\n  // https://github.com/facebook/react/issues/11211\n\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n      // @ts-ignore The `beforeinput` event isn't recognized.\n      ref.current.addEventListener('beforeinput', onDOMBeforeInput);\n    }\n\n    return () => {\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    };\n  }, [onDOMBeforeInput]); // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n\n  useIsomorphicLayoutEffect(() => {\n    var window = ReactEditor.getWindow(editor);\n    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    return () => {\n      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    };\n  }, [scheduleOnDOMSelectionChange]);\n  var decorations = decorate([editor, []]);\n\n  if (placeholder && editor.children.length === 1 && Array.from(Node.texts(editor)).length === 1 && Node.string(editor) === '' && !isComposing) {\n    var start = Editor.start(editor, []);\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      anchor: start,\n      focus: start\n    });\n  }\n\n  var {\n    marks\n  } = editor;\n  state.hasMarkPlaceholder = false;\n\n  if (editor.selection && Range.isCollapsed(editor.selection) && marks) {\n    var {\n      anchor\n    } = editor.selection;\n    var leaf = Node.leaf(editor, anchor.path);\n\n    var rest = _objectWithoutProperties(leaf, _excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n\n\n    if (!Text$1.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(mark => [mark, null]));\n      decorations.push(_objectSpread$1(_objectSpread$1(_objectSpread$1({\n        [MARK_PLACEHOLDER_SYMBOL]: true\n      }, unset), marks), {}, {\n        anchor,\n        focus: anchor\n      }));\n    }\n  } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n\n\n  useEffect(() => {\n    setTimeout(() => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        var {\n          anchor: _anchor\n        } = selection;\n\n        var _text = Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n\n\n        if (marks && !Text$1.equals(_text, marks, {\n          loose: true\n        })) {\n          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n\n      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n    });\n  });\n  useEffect(() => {\n    mountedCount++;\n\n    if (mountedCount === 1) {\n      // Set global default styles for editors.\n      var defaultStylesElement = document.createElement('style');\n      defaultStylesElement.setAttribute('data-slate-default-styles', 'true');\n      defaultStylesElement.innerHTML = // :where is used to give these rules lower specificity so user stylesheets can override them.\n      \":where([data-slate-editor]) {\" + // Allow positioning relative to the editable element.\n      \"position: relative;\" + // Prevent the default outline styles.\n      \"outline: none;\" + // Preserve adjacent whitespace and new lines.\n      \"white-space: pre-wrap;\" + // Allow words to break if they are too long.\n      \"word-wrap: break-word;\" + \"}\";\n      document.head.appendChild(defaultStylesElement);\n    }\n\n    return () => {\n      var _document$querySelect;\n\n      mountedCount--;\n      if (mountedCount <= 0) (_document$querySelect = document.querySelector('style[data-slate-default-styles]')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.remove();\n    };\n  }, []);\n  useEffect(() => {\n    var styleElement = document.createElement('style');\n    document.head.appendChild(styleElement);\n    EDITOR_TO_STYLE_ELEMENT.set(editor, styleElement);\n    return () => {\n      styleElement.remove();\n      EDITOR_TO_STYLE_ELEMENT.delete(editor);\n    };\n  }, []);\n  return /*#__PURE__*/React.createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/React.createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/React.createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/React.createElement(Component, Object.assign({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-editor-id\": editor.id,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: ref,\n    style: style,\n    onBeforeInput: useCallback(event => {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          Editor.insertText(editor, _text2);\n        }\n      }\n    }, [readOnly]),\n    onInput: useCallback(event => {\n      if (androidInputManager) {\n        androidInputManager.handleInput();\n        return;\n      } // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n\n\n      for (var op of deferredOperations.current) {\n        op();\n      }\n\n      deferredOperations.current = [];\n    }, []),\n    onBlur: useCallback(event => {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      } // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n\n\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n\n      if (relatedTarget === el) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n\n\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n\n\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n\n        if (Element$1.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      } // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n\n\n      if (IS_SAFARI) {\n        var domSelection = root.getSelection();\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n      }\n\n      IS_FOCUSED.delete(editor);\n    }, [readOnly, attributes.onBlur]),\n    onClick: useCallback(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n\n        if (!Editor.hasPath(editor, path) || Node.get(editor, path) !== node) {\n          return;\n        }\n\n        if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n\n          if (!Editor.isBlock(editor, node)) {\n            var _block$;\n\n            var block = Editor.above(editor, {\n              match: n => Editor.isBlock(editor, n),\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n\n          var range = Editor.range(editor, blockPath);\n          Transforms.select(editor, range);\n          return;\n        }\n\n        if (readOnly) {\n          return;\n        }\n\n        var _start = Editor.start(editor, path);\n\n        var end = Editor.end(editor, path);\n        var startVoid = Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = Editor.void(editor, {\n          at: end\n        });\n\n        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {\n          var _range = Editor.range(editor, _start);\n\n          Transforms.select(editor, _range);\n        }\n      }\n    }, [readOnly, attributes.onClick]),\n    onCompositionEnd: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        if (ReactEditor.isComposing(editor)) {\n          setIsComposing(false);\n          IS_COMPOSING.set(editor, false);\n        }\n\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);\n\n        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n          return;\n        } // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n\n\n        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor); // Ensure we insert text with the marks the user was actually seeing\n\n          if (placeholderMarks !== undefined) {\n            EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n\n          Editor.insertText(editor, event.data);\n          var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n          EDITOR_TO_USER_MARKS.delete(editor);\n\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd]),\n    onCompositionUpdate: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate]),\n    onCompositionStart: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);\n\n        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n          return;\n        }\n\n        setIsComposing(true);\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n            return;\n          }\n\n          var inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var [, inlinePath] = inline;\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n      }\n    }, [attributes.onCompositionStart]),\n    onCopy: useCallback(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy]),\n    onCut: useCallback(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n          } else {\n            var node = Node.parent(editor, selection.anchor.path);\n\n            if (Editor.isVoid(editor, node)) {\n              Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onCut]),\n    onDragOver: useCallback(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n\n        if (Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver]),\n    onDragStart: useCallback(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = Editor.isVoid(editor, node) || Editor.void(editor, {\n          at: path,\n          voids: true\n        }); // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n\n        if (voidMatch) {\n          var range = Editor.range(editor, path);\n          Transforms.select(editor, range);\n        }\n\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, attributes.onDragStart]),\n    onDrop: useCallback(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault(); // Keep a reference to the dragged range before updating selection\n\n        var draggedRange = editor.selection; // Find the range where the drop happened\n\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        Transforms.select(editor, range);\n\n        if (state.isDraggingInternally) {\n          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {\n            at: range,\n            voids: true\n          })) {\n            Transforms.delete(editor, {\n              at: draggedRange\n            });\n          }\n        }\n\n        ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n\n      state.isDraggingInternally = false;\n    }, [readOnly, attributes.onDrop]),\n    onDragEnd: useCallback(event => {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      } // When dropping on a different droppable element than the current editor,\n      // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n      // Note: `onDragEnd` is only called when `onDrop` is not called\n\n\n      state.isDraggingInternally = false;\n    }, [readOnly, attributes.onDragEnd]),\n    onFocus: useCallback(event => {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, attributes.onFocus]),\n    onKeyDown: useCallback(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleKeyDown(event);\n        var {\n          nativeEvent\n        } = event; // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n\n        var {\n          selection\n        } = editor;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = getDirection(Node.string(element)) === 'rtl'; // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n\n          return;\n        } // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n\n\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        } // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n\n\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'start'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'end'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n\n\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n\n          if (Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertSoftBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n        } else {\n          if (IS_CHROME || IS_SAFARI) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {\n              var currentNode = Node.parent(editor, selection.anchor.path);\n\n              if (Element$1.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onKeyDown]),\n    onPaste: useCallback(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, attributes.onPaste])\n  }), /*#__PURE__*/React.createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: editor.selection\n  })))));\n};\n/**\r\n * The default placeholder element\r\n */\n\nvar DefaultPlaceholder = _ref => {\n  var {\n    attributes,\n    children\n  } = _ref;\n  return (\n    /*#__PURE__*/\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    React.createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/React.createElement(\"br\", null))\n  );\n};\n/**\r\n * A default memoized decorate function.\r\n */\n\nvar defaultDecorate = () => [];\n/**\r\n * A default implement to scroll dom range into view.\r\n */\n\nvar defaultScrollSelectionIntoView = (editor, domRange) => {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    scrollIntoView(leafEl, {\n      scrollMode: 'if-needed'\n    }); // @ts-expect-error an unorthodox delete D:\n\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */\n\n\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */\n\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.defaultPrevented;\n};\n\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */\n\nvar FocusedContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */\n\nvar useFocused = () => {\n  return useContext(FocusedContext);\n};\n\nfunction isError(error) {\n  return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */\n\n\nvar SlateSelectorContext = /*#__PURE__*/createContext({});\n\nvar refEquality = (a, b) => a === b;\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */\n\n\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n  var [, forceRender] = useReducer(s => s + 1, 0);\n  var context = useContext(SlateSelectorContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var {\n    getSlate,\n    addEventListener\n  } = context;\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef(() => null);\n  var latestSelectedState = useRef(null);\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(getSlate());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n\n    throw err;\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(() => {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(getSlate());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender();\n    }\n\n    var unsubscribe = addEventListener(checkForUpdates);\n    checkForUpdates();\n    return () => unsubscribe();\n  }, // don't rerender on equalityFn change since we want to be able to define it inline\n  [addEventListener, getSlate]);\n  return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */\n\nfunction getSelectorContext(editor) {\n  var eventListeners = useRef([]).current;\n  var slateRef = useRef({\n    editor\n  }).current;\n  var onChange = useCallback(editor => {\n    slateRef.editor = editor;\n    eventListeners.forEach(listener => listener(editor));\n  }, []);\n  var selectorContext = useMemo(() => {\n    return {\n      getSlate: () => slateRef.editor,\n      addEventListener: callback => {\n        eventListeners.push(callback);\n        return () => {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext,\n    onChange\n  };\n}\n\nvar _excluded = [\"editor\", \"children\", \"onChange\", \"value\"];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */\n\nvar Slate = props => {\n  var {\n    editor,\n    children,\n    onChange,\n    value\n  } = props,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var unmountRef = useRef(false);\n  var [context, setContext] = React.useState(() => {\n    if (!Node.isNodeList(value)) {\n      throw new Error(\"[Slate] value is invalid! Expected a list of elements but got: \".concat(Scrubber.stringify(value)));\n    }\n\n    if (!Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! You passed: \".concat(Scrubber.stringify(editor)));\n    }\n\n    editor.children = value;\n    Object.assign(editor, rest);\n    return {\n      v: 0,\n      editor\n    };\n  });\n  var {\n    selectorContext,\n    onChange: handleSelectorChange\n  } = getSelectorContext(editor);\n  var onContextChange = useCallback(() => {\n    if (onChange) {\n      onChange(editor.children);\n    }\n\n    setContext(prevContext => ({\n      v: prevContext.v + 1,\n      editor\n    }));\n    handleSelectorChange(editor);\n  }, [onChange]);\n  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n  useEffect(() => {\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {});\n      unmountRef.current = true;\n    };\n  }, []);\n  var [isFocused, setIsFocused] = useState(ReactEditor.isFocused(editor));\n  useEffect(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  });\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n\n    if (IS_REACT_VERSION_17_OR_ABOVE) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return () => {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return () => {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/React.createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/React.createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(EditorContext.Provider, {\n    value: context.editor\n  }, /*#__PURE__*/React.createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\n\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */\n\nvar useEditor = () => {\n  var editor = useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */\n\nvar useSlateSelection = () => {\n  return useSlateSelector(editor => editor.selection, isSelectionEqual);\n};\n\nvar isSelectionEqual = (a, b) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return Range.equals(a, b);\n};\n\n/**\r\n * Utilities for single-line deletion\r\n */\n\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\n\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */\n\n\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));\n  var positions = Array.from(Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n\n    middle = Math.floor((left + right) / 2);\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withReact = editor => {\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n\n    if (e.selection && Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = Editor.above(e, {\n        match: n => Editor.isBlock(e, n),\n        at: e.selection\n      });\n\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n\n\n  e.apply = op => {\n    var matches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, Path.parent(op.path)));\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var prevPath = Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n\n      case 'move_node':\n        {\n          var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          break;\n        }\n    }\n\n    apply(op);\n\n    for (var [path, key] of matches) {\n      var [node] = Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n  };\n\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n\n    if (!selection) {\n      return;\n    }\n\n    var [start, end] = Range.edges(selection);\n    var startVoid = Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = Editor.void(e, {\n      at: end.path\n    });\n\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return;\n    } // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n\n\n    var domRange = ReactEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    }); // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = ReactEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    } // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n\n\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    } // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n\n\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData('application/x-slate-fragment', encoded); // Add the content to a <div> so that we can get its inner HTML.\n\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n\n  e.insertFragmentData = data => {\n    /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */\n    var fragment = data.getData('application/x-slate-fragment') || getSlateFragmentAttribute(data);\n\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n\n    return false;\n  };\n\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n\n      for (var line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n\n        e.insertText(line);\n        split = true;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  e.onChange = () => {\n    // COMPAT: React doesn't batch `setState` hook calls, which means that the\n    // children and selection can get out of sync for one render pass. So we\n    // have to use this unstable API to ensure it batches them. (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    ReactDOM.unstable_batchedUpdates(() => {\n      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n\n      if (onContextChange) {\n        onContextChange();\n      }\n\n      onChange();\n    });\n  };\n\n  return e;\n};\n\nvar getMatches = (e, path) => {\n  var matches = [];\n\n  for (var [n, p] of Editor.levels(e, {\n    at: path\n  })) {\n    var key = ReactEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n\n  return matches;\n};\n\nexport { DefaultElement, DefaultLeaf, DefaultPlaceholder, Editable, ReactEditor, Slate, useEditor, useFocused, useReadOnly, useSelected, useSlate, useSlateSelection, useSlateSelector, useSlateStatic, useSlateWithV, withReact };\n//# sourceMappingURL=index.es.js.map\n"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_objectWithoutProperties","source","excluded","i","target","_objectWithoutPropertiesLoose","sourceKeys","keys","length","indexOf","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","n","Key","constructor","id","concat","NODE_TO_INDEX","WeakMap","NODE_TO_PARENT","EDITOR_TO_WINDOW","EDITOR_TO_ELEMENT","EDITOR_TO_PLACEHOLDER_ELEMENT","ELEMENT_TO_NODE","NODE_TO_ELEMENT","NODE_TO_KEY","EDITOR_TO_KEY_TO_ELEMENT","EDITOR_TO_STYLE_ELEMENT","IS_READ_ONLY","IS_FOCUSED","IS_COMPOSING","EDITOR_TO_USER_SELECTION","EDITOR_TO_ON_CHANGE","EDITOR_TO_SCHEDULE_FLUSH","EDITOR_TO_PENDING_INSERTION_MARKS","EDITOR_TO_USER_MARKS","EDITOR_TO_PENDING_DIFFS","EDITOR_TO_PENDING_ACTION","EDITOR_TO_PENDING_SELECTION","EDITOR_TO_FORCE_RENDER","PLACEHOLDER_SYMBOL","Symbol","MARK_PLACEHOLDER_SYMBOL","DOMText","globalThis","Text","getDefaultView","ownerDocument","defaultView","isDOMComment","isDOMNode","nodeType","isDOMElement","window","Node","isDOMSelection","anchorNode","Selection","isDOMText","isPlainTextOnlyPaste","event","clipboardData","getData","types","normalizeDOMPoint","domPoint","node","offset","childNodes","isLast","index","getEditableChildAndIndex","getEditableChild","textContent","hasShadowRoot","parent","parentNode","toString","direction","child","triedForward","triedBackward","getAttribute","getPlainText","domNode","text","nodeValue","childNode","Array","from","display","getComputedStyle","getPropertyValue","tagName","catchSlateFragment","getSlateFragmentAttribute","dataTransfer","fragment","htmlData","match","isTrackedMutation","editor","mutation","batch","matches","document","ReactEditor","getWindow","contains","hasDOMNode","editable","parentMutation","find","_ref","addedNodes","removedNodes","_node","IS_REACT_VERSION_17_OR_ABOVE","parseInt","react__WEBPACK_IMPORTED_MODULE_3__","version","split","IS_IOS","navigator","test","userAgent","MSStream","IS_APPLE","IS_ANDROID","IS_FIREFOX","IS_SAFARI","IS_EDGE_LEGACY","IS_CHROME","IS_CHROME_LEGACY","IS_FIREFOX_LEGACY","IS_UC_MOBILE","IS_WECHATBROWSER","CAN_USE_DOM","createElement","HAS_BEFORE_INPUT_SUPPORT","InputEvent","getTargetRanges","isComposing","get","findKey","set","findPath","path","slate__WEBPACK_IMPORTED_MODULE_6__","ML","isEditor","unshift","o4","stringify","findDocumentOrShadowRoot","el","toDOMNode","root","getRootNode","Document","ShadowRoot","getSelection","isFocused","isReadOnly","blur","activeElement","focus","preventScroll","deselect","selection","domSelection","rangeCount","removeAllRanges","YR","targetEl","options","arguments","undefined","editorEl","parentElement","err","message","includes","closest","isContentEditable","insertData","data","insertFragmentData","insertTextData","setFragmentData","originEvent","KEY_TO_ELEMENT","toDOMPoint","point","at","texts","querySelectorAll","start","attr","end","nextText","hasAttribute","_nextText$textContent","domText","startsWith","Math","min","max","toDOMRange","range","anchor","isBackward","e6","domAnchor","domFocus","isCollapsed","domRange","createRange","startNode","startOffset","endNode","endOffset","isStartAtZeroWidth","startEl","isEndAtZeroWidth","endEl","setStart","setEnd","toSlateNode","domEl","findEventRange","nativeEvent","clientX","x","clientY","y","isVoid","rect","getBoundingClientRect","isPrev","isInline","left","width","top","height","edge","before","after","caretRangeFromPoint","position","caretPositionFromPoint","offsetNode","toSlateRange","exactMatch","suppressThrow","toSlatePoint","nearestNode","nearestOffset","textNode","_domNode$textContent","_domNode$textContent2","potentialVoidNode","voidNode","leafNode","contents","cloneContents","removals","slice","forEach","textContext","removeChild","leafNodes","current","endsWith","_slateNode","_path","_offset","querySelector","slateNode","anchorOffset","focusNode","focusOffset","startContainer","endContainer","collapsed","isExpanded","isForward","mode","unhangRange","voids","hasRange","hasPath","hasTarget","hasEditableTarget","hasSelectableTarget","isTargetInsideNonReadonlyVoid","androidScheduleFlush","_EDITOR_TO_SCHEDULE_F","androidPendingDiffs","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","_excluded$3","_excluded2$1","shallowCompare","obj1","obj2","every","hasOwnProperty","isDecoratorRangeListEqual","list","another","other","rangeOwnProps","otherOwnProps","equals","String","props","leaf","useSlateStatic","parentPath","y$","isMarkPlaceholder","ZeroWidthString","NB","string","children","TextString","isTrailing","isLineBreak","ref","useRef","getTextContent","textWithTrailing","attributes","assign","EditorContext","createContext","useContext","Leaf","renderPlaceholder","renderLeaf","DefaultLeaf","placeholderRef","placeholderResizeObserver","disconnect","placeholderEl","delete","observe","ResizeObserver","styleElement","minHeight","clientHeight","innerHTML","placeholderProps","placeholder","style","pointerEvents","maxWidth","opacity","userSelect","textDecoration","contentEditable","Fragment","MemoizedLeaf","memo","prev","next","xv","decorations","leaves","push","MemoizedText","Element","element","renderElement","p","DefaultElement","readOnly","useReadOnly","useCallback","useChildren","hasInlines","dir","direction__WEBPACK_IMPORTED_MODULE_0___default","_text","color","outline","MemoizedElement","Tag","DecorateContext","useDecorate","SelectedContext","useSelected","decorate","isLeafBlock","W_","isElement","sel","intersection","ds","dec","d","Provider","ReadOnlyContext","SlateContext","useSlate","context","HOTKEYS","bold","compose","moveBackward","moveForward","moveWordBackward","moveWordForward","deleteBackward","deleteForward","extendBackward","extendForward","italic","insertSoftBreak","splitBlock","undo","APPLE_HOTKEYS","moveLineBackward","moveLineForward","deleteLineBackward","deleteLineForward","deleteWordBackward","deleteWordForward","extendLineBackward","extendLineForward","redo","transposeCharacter","WINDOWS_HOTKEYS","create","generic","apple","windows","isGeneric","is_hotkey__WEBPACK_IMPORTED_MODULE_4__","TB","isApple","isWindows","Hotkeys","isBold","isCompose","isMoveBackward","isMoveForward","isDeleteBackward","isDeleteForward","isDeleteLineBackward","isDeleteLineForward","isDeleteWordBackward","isDeleteWordForward","isExtendBackward","isExtendForward","isExtendLineBackward","isExtendLineForward","isItalic","isMoveLineBackward","isMoveLineForward","isMoveWordBackward","isMoveWordForward","isRedo","isSoftBreak","isSplitBlock","isTransposeCharacter","isUndo","createRestoreDomManager","receivedUserInput","bufferedMutations","clear","registerMutations","mutations","trackedMutations","filter","restoreDOM","reverse","type","oldValue","insertBefore","nextSibling","MUTATION_OBSERVER_CONFIG$1","subtree","childList","characterData","characterDataOldValue","RestoreDOMComponent","Component","manager","mutationObserver","_this$mutationObserve","componentDidMount","MutationObserver","getSnapshotBeforeUpdate","_this$mutationObserve2","_this$mutationObserve3","_this$manager2","_this$manager","pendingMutations","takeRecords","componentDidUpdate","_this$manager3","componentWillUnmount","_this$mutationObserve4","render","contextType","RestoreDOM","normalizeStringDiff","targetText","diff","removedText","prefixLength","longestCommonPrefixLength","str","charAt","suffixLength","longestCommonSuffixLength","normalized","normalizePoint","isText","parentBlock","above","isBlock","entry","isDescendant","normalizeRange","transformPendingPoint","op","pendingDiffs","textDiff","E9","transform","affinity","_anchor","_transformed","transformed","transformPendingRange","ownKeys$3","object","enumerableOnly","symbols","sym","getOwnPropertyDescriptor","apply","_objectSpread$3","getOwnPropertyDescriptors","defineProperties","debug","_excluded$2","ownKeys$2","MUTATION_OBSERVER_CONFIG","_excluded$1","_excluded2","ownKeys$1","_objectSpread$1","Children","mountedCount","Editable","animationFrameIdRef","onUserInput","autoFocus","defaultDecorate","onDOMBeforeInput","propsOnDOMBeforeInput","DefaultPlaceholder","scrollSelectionIntoView","defaultScrollSelectionIntoView","as","setIsComposing","useState","deferredOperations","cancelAnimationFrame","requestAnimationFrame","forceRender","useReducer","s","state","useMemo","isDraggingInternally","isUpdatingSelection","latestElement","hasMarkPlaceholder","onDOMSelectionChange","lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default","androidInputManager","isFlushing","anchorNodeSelectable","focusNodeSelectable","hasPendingChanges","handleUserSelect","select","scheduleOnDOMSelectionChange","lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default","useAndroidInputManager","isMountedRef","isMounted","inputManager","createAndroidInputManager","flushing","compositionEndTimeoutId","flushTimeoutId","actionTimeoutId","idCounter","insertPositionHint","applyPendingSelection","pendingSelection","performAction","action","isPoint","_targetRange","run","flush","clearTimeout","hasPendingDiffs","hasPendingAction","setTimeout","selectionRef","rangeRef","marks","scheduleSelectionChange","_EDITOR_TO_PENDING_DI","_EDITOR_TO_PENDING_DI2","_EDITOR_TO_PENDING_DI3","pendingMarks","targetRange","insertText","deleteFragment","_ref2","verifyDiffState","nextPath","nextNode","cancel","unref","userMarks","onChange","handleCompositionEnd","_event","handleCompositionStart","updatePlaceholderVisibility","forceHide","placeholderElement","removeProperty","storeDiff","a","overlap","applied","sliceEnd","_EDITOR_TO_PENDING_DI4","idx","findIndex","change","merged","b","applyStringDiff","_len","diffs","_key","reduce","splice","scheduleAction","handleDOMBeforeInput","inputType","nativeTargetRange","_targetRange2","edges","_start","_end","targetNode","_nativeTargetRange","nativeCollapsed","unit","insertBreak","name","replace","_start2","_end2","hintPosition","search","diffPosition","scheduleFlush","_EDITOR_TO_PENDING_DI5","pathChanged","parentPathChanged","handleInput","handleKeyDown","_","handleDomMutations","some","_EDITOR_TO_FORCE_REND","_objectSpread$2","useMutationObserver","callback","setDomSelection","forceChange","hasDomSelection","editorElement","hasDomSelectionInEditor","slateRange","_anchorNode$parentEle","newDomRange","setBaseAndExtent","ensureSelection","timeoutId","animationFrameId","ensureDomSelection","e","isDOMEventHandled","isCompositionChange","native","_node$parentElement","_EDITOR_TO_USER_SELEC","_window$getComputedSt","_lastText$textContent","lastText","createTreeWalker","NodeFilter","SHOW_TEXT","lastChild","whiteSpace","block","preventDefault","toRestore","addEventListener","removeEventListener","rest","loose","unset","fromEntries","map","mark","defaultStylesElement","setAttribute","head","appendChild","_document$querySelect","remove","role","spellCheck","autoCorrect","autoCapitalize","zindex","suppressContentEditableWarning","onBeforeInput","isEventHandled","_text2","onInput","onBlur","relatedTarget","onClick","detail","blockPath","_block$","startVoid","endVoid","_range","onCompositionEnd","placeholderMarks","onCompositionUpdate","onCompositionStart","inline","inlinePath","isEnd","setSelection","onCopy","onCut","onDragOver","onDragStart","onDrop","draggedRange","onDragEnd","onFocus","onKeyDown","isRTL","maybeHistoryEditor","_maybeHistoryEditor","move","collapse","currentNode","onPaste","leafEl","bind","scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_7__","Z","scrollMode","handler","shouldTreatEventAsHandled","isDefaultPrevented","isPropagationStopped","defaultPrevented","FocusedContext","useFocused","SlateSelectorContext","_excluded","Slate","eventListeners","slateRef","selectorContext","unmountRef","setContext","isNodeList","v","handleSelectorChange","listener","getSlate","onContextChange","prevContext","setIsFocused","fn","doRectsIntersect","compareRect","middle","bottom","areRangesSameLine","range1","range2","rect1","rect2","findCurrentLineRange","parentRange","parentRangeBoundary","positions","right","floor","ownKeys","_objectSpread","withReact","addMark","removeMark","parentBlockEntry","parentBlockPath","parentElementRange","currentLineRange","transformTextDiff","newPath","Boolean","pendingAction","getMatches","previous","common","attach","trim","r","cloneRange","setEndAfter","zw","isNewline","span","JSON","getFragment","encoded","btoa","encodeURIComponent","setData","div","body","parsed","parse","decodeURIComponent","atob","insertFragment","lines","line","splitNodes","always","react_dom__WEBPACK_IMPORTED_MODULE_5__","unstable_batchedUpdates","levels"],"sourceRoot":""}